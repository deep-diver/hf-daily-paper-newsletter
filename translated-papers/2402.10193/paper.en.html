<!DOCTYPE html>
<html lang="en" data-lt-installed="true"><head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    const text = '' +
      '# BitDelta: Your Fine-Tune May Only Be Worth One Bit\n' +
      '\n' +
      ' James Liu\n' +
      '\n' +
      'Guangxuan Xiao\n' +
      '\n' +
      'Kai Li\n' +
      '\n' +
      'Jason D. Lee\n' +
      '\n' +
      'Song Han\n' +
      '\n' +
      'Tri Dao\n' +
      '\n' +
      'Tianle Cai\n' +
      '\n' +
      'Equal contribution 1Massachusetts Institute of Technology2Princeton University 3Together AI. Correspondence to: James Liu <jamesll@mit.edu>, Tianle Cai <tainle.cai@princeton.edu>. Tianle\'s contribution was partially done during consulting at Together AI.\n' +
      '\n' +
      '###### Abstract\n' +
      '\n' +
      'Large Language Models (LLMs) are typically trained in two phases: pre-training on large internet-scale datasets, and fine-tuning for downstream tasks. Given the higher computational demand of pre-training, it\'s intuitive to assume that fine-tuning adds less new information to the model, and is thus more compressible. We explore this assumption by decomposing the weights of fine-tuned models into their pre-trained components and an additional _delta_. We introduce a simple method, BitDelta, which successfully quantizes this delta down to 1 bit without compromising performance. This interesting finding not only highlights the potential redundancy of information added during fine-tuning, but also has significant implications for the multi-tenant serving and multi-tenant storage of fine-tuned models. By enabling the use of a single high-precision base model accompanied by multiple 1-bit deltas, BitDelta dramatically reduces GPU memory requirements by more than 10\\(\\times\\), which can also be translated to enhanced generation latency in multi-tenant settings. We validate BitDelta through experiments across Llama-2 and Mistral model families, and on models up to 70B parameters, showcasing minimal performance degradation over all tested settings. Code is avaliable at [https://github.com/FasterDecoding/BitDelta](https://github.com/FasterDecoding/BitDelta).\n' +
      '\n' +
      'Machine Learning, ICML\n' +
      '\n' +
      '## 1 Introduction\n' +
      '\n' +
      'After large-scale pretraining, foundation models are typically fine-tuned for specific downstream tasks (Devlin et al., 2019; Radford et al., 2018, 2019). This _pretrain-finetune_ paradigm has revolutionized machine learning; LLMs have not only proven effective for critical tasks such as instruction following and alignment (Ouyang et al., 2022), but are also performant on a wide array of niche yet highly impactful applications (Xu et al., 2024; Qiu et al., 2023). Through fine-tuning, LLMs are adeptly equipped to align with distinct user preferences or specialized task requirements, showcasing an unprecedented level of adaptability. Thus, the prospect of serving millions of uniquely fine-tuned models, each tailored to individual tasks and user needs, presents a promising vision for the future of machine learning.\n' +
      '\n' +
      'Realizing this vision is challenging due to two key reasons: 1) **Expensive Storage.** Each new fine-tuned model is large, even if we have relatively few base models, making them expensive to store and challenging to manage on disk. 2) **Expensive Serving.** Distinct fine-tuned models each demand significant GPU memory, making it difficult and expensive to concurrently serve such models without noticeable downtime. To tackle these issues, we decompose the fine-tuned model weights into the weights of the base pre-trained model and a _delta_ induced by the fine-tuning process. By compressing this delta while maintaining model performance, we aim to sidestep the prohibitive costs associated with storage and GPU memory demands.\n' +
      '\n' +
      'From the delta decomposition point of view, parameter-efficient fine-tuning (PEFT) methods like LoRA (Hu et al., 2021; Houlsby et al., 2019; Rebuffi et al., 2017; Dettmers et al., 2023; Chen et al., 2023d) effectively enforce a highly structured and compressed form of delta _during fine-tuning_, a powerful insight for model serving of PEFT-based fine-tunes. (Sheng et al., 2023) and (Chen et al., 2023b) explore multi-tenant serving of LoRA-based fine-tunes.\n' +
      '\n' +
      'Nevertheless, recent work has shown that PEFT methods may not yet match the model quality of full parameter fine-tuning, especially on high resource tasks (Chen et al., 2022), and are fairly sensitive to hyperparameter choice and prompting methods (Niederfahrenhorst et al., 2023). As a result, we notice that among the 2307 LLMs (as of time of writing) on the Open LLM Leaderboard (Beeching et al., 2023) with a valid README file, only \\(<20\\%\\) indicate that they exclusively use LoRA. Most models are full parameter fine-tunes, model merges (Yu et al., 2023; Jin et al., 2023; Wortsman et al., 2022) of full parameter fine-tunes, or model merges of LoRA based fine-tunes (whichare effectively high-rank).\n' +
      '\n' +
      'It is also attractive to approximate general deltas with low-rank matrices _post-training_. However, experimental results show that this is challenging (Table 1), as deltas from full parameter fine-tunes tend to be fairly high-rank (Figure 2).\n' +
      '\n' +
      'Instead, we draw from the insight that motivates PEFT methods in general: Given the higher computational demand of pre-training, it\'s intuitive to assume that fine-tuning adds less new information to the model, and is thus _much_ more compressible. Indeed, we find that we can efficiently _quantize_ the delta to merely _1 bit_ with almost no performance drop. We propose BitDelta, an efficient post-training quantization (PTQ) solution that acts on the weight delta between a fine-tuned model and its underlying base model.\n' +
      '\n' +
      'BitDelta has two stages: 1) We quantize the delta of each weight matrix into a scaling factor multiplied by a binary matrix. Specifically, we take the sign of the delta to form the binary matrix and initialize the scaling factor as the average of the absolute values of the delta, which minimizes \\(L_{2}\\) norm. 2) We further calibrate the scaling factors through model distillation over a small calibration dataset while keeping the binary matrices frozen. Despite the small number of trainable parameters and training steps, we find that this distillation process is effective in further recovering model quality. BitDelta is extremely efficient compared to other quantization methods; we are able to compress 70B models in roughly 10 minutes, whereas methods like GPTQ (Frantar et al., 2022) and AWQ (Lin et al., 2023) may take multiple GPU hours. Our experiments over 17 popular fine-tuned models affirm that BitDelta can be applied across various model types and sizes with minimal impact on performance.\n' +
      '\n' +
      'BitDelta opens up opportunities to efficiently serve multiple fine-tuned models with shared servers: By only storing a single full-precision base model, and (dynamically) load\n' +
      '\n' +
      'Figure 1: **Overview of BitDelta. BitDelta applies 1-bit quantization to the weight delta between fine-tuned and base models. For each weight matrix, we quantize its delta as its sign bits and a trainable high-precision scale factor. The scale factor is initialized to achieve the best approximation error in \\(L_{2}\\) norm and further refined with a few distillation steps. BitDelta shows minimal degradation in model performance and reduces memory consumption in multi-tenancy serving by representing multiple fine-tuned models with a single high-precision base model and multiple 1-bit deltas.**\n' +
      '\n' +
      'Figure 2: CEV plot of a \\(4096\\times 4096\\) weight delta between _Llama 2-7B_ and _Vicuna-7B v1.5_. Deltas from full parameter fine-tuning are fairly high rank, making low-rank approximations difficult.\n' +
      '\n' +
      'ing and performing batched inference over multiple 1-bit deltas, we can efficiently represent multiple fine-tuned models. Compared to naively using full precision fine-tuned models, deltas compressed by BitDelta are more than 10\\(\\times\\) smaller, consuming less GPU memory, and can therefore be loaded faster. This addresses the storage challenge. Moreover, since LLM inference is memory-bound (Leviathan et al., 2022; Chen et al., 2023; Cai et al., 2024), the latency of each decoding step is proportional to the GPU memory consumption of the model weights. With an efficient CUDA kernel implementation, we can translate this memory reduction into a latency speedup, similar to other quantization methods (Frantar et al., 2022; Lin et al., 2023). As a preliminary attempt, we implement a 1-bit matrix multiplication kernel in Triton (Tillet et al., 2019) and show that it can improve the multi-tenant serving latency by about 2\\(\\times\\), addressing the serving challenge.\n' +
      '\n' +
      'Finally, we study a few extensions of BitDelta, where we quantize the base model, and where we iteratively apply BitDelta. Experimental results show that our method is quite general and can be applied to various use cases.\n' +
      '\n' +
      '## 2 Related Work\n' +
      '\n' +
      '### Full Model Compression\n' +
      '\n' +
      'Quantization.Quantization techniques are widely used to reduce memory consumption and improve LLMs\' generation latency. Xiao et al. (2023) implement a technique that rescales between activations and parameters, effectively mitigating outlier activations to facilitate smoother quantization. Dettmers et al. (2022) develop an approach that decomposes matrix multiplications into 8-bit computations, with an additional 16-bit process for handling outliers. Exploring further, Frantar et al. (2022) introduce a method that iteratively rounds weight columns to 3-4 bits of precision. Similarly, Lin et al. (2023) propose an activation-aware quantization scheme that selectively preserves crucial weights while compressing the majority to 3-4 bits. In a different vein, Kim et al. (2023) devise a sparse, low-precision pattern focusing on a small yet significant set of weights. Lastly, Chee et al. (2023) utilize incoherence processing to quantize model weights to as low as 2 bits with minimal impact on performance.\n' +
      '\n' +
      'Pruning.Pruning also aims to reduce the memory consumption of neural networks. It accomplishes this by pushing certain parameter values to zero, inducing sparsity in the model (LeCun et al., 1989; Han et al., 2015, 2016; Zhu and Gupta, 2017). However, these methods may fail to take advantage of modern hardware like GPUs unless using certain structured sparsity patterns like 2:4 (50%) sparsity (Mishra et al., 2021). Frantar and Alistarh (2023) demonstrate a pruning method on LLMs that successfully utilizes the 2:4 sparsity pattern and achieves a 50% sparsity ratio. It is challenging to obtain higher sparsity while being hardware-friendly.\n' +
      '\n' +
      '### Delta Compression\n' +
      '\n' +
      'Parameter-efficient fine-tuning.Parameter-efficient fine-tuning (PEFT) techniques reduce the number of trainable parameters during fine-tuning, reducing memory and compute demand while achieving promising accuracy. Houlsby et al. (2019) introduce adapter layers, freezing the base model during fine-tuning. Hu et al. (2021) propose Low-Rank Adaptation (LoRA), which enforces that weight updates during fine-tuning are low rank.\n' +
      '\n' +
      'By enforcing structure in the fine-tuning information, PEFT techniques can viewed as _compression-aware training_. Similar to our method, such compression induced by PEFT techniques can also enhance multi-tenant serving. Chen et al. (2023) and Sheng et al. (2023) explore this idea by developing scalable multi-tenant systems for LoRA-based fine-tunes, based on customized CUDA kernels that exploit the low-rank structure of the fine-tuned weight deltas.\n' +
      '\n' +
      'Early work on post-training delta compression.Most related to our work, a few studies explore the idea of post-training delta compression (Isik et al., 2023; Yao and Klimovic, 2023; Yu et al., 2023) by adopting existing compression techniques like GPTQ, unstructured pruning (Han et al., 2016), or even classic lossless compression algorithms. Isik et al. (2023) focus on reducing the delta size to save storage. Yu et al. (2023) utilize pruning to improve model merging applications. The concurrent and independent work by Yao and Klimovic (2023) also explores using delta compression to improve multi-tenant serving, but focuses more on reducing the model loading time from disk to GPU. Compared to existing work, we offer a much simpler and faster method, BitDelta, achieving a more than 10\\(\\times\\) compression ratio while also being friendly to modern accelerators.\n' +
      '\n' +
      '## 3 BitDelta\n' +
      '\n' +
      '### Method\n' +
      '\n' +
      'BitDelta consists of two stages: 1) We quantize each weight matrix into a scalar multiplied by a binary matrix*. 2) We further calibrate the scalar factors with distillation. We describe each stage in this section:1-bit quantization.Let \\(W_{\\text{base}},W_{\\text{fine}}\\in\\mathbb{R}^{n\\times m}\\) be weight matrices from the base model and fine-tuned model, respectively. We define the weight delta as \\(\\Delta=W_{\\text{fine}}-W_{\\text{base}}\\), representing the modification in weights post-fine-tuning. For efficient representation, we aim to obtain a binarized estimator of this weight delta, denoted as \\(\\hat{\\Delta}\\), by encoding its sign bits:\n' +
      '\n' +
      '\\[\\hat{\\Delta}=\\alpha\\odot\\text{Sign}(\\Delta), \\tag{1}\\]\n' +
      '\n' +
      'where\n' +
      '\n' +
      '\\[\\text{Sign}(W_{ij})=\\begin{cases}+1,&\\text{if }W_{ij}>0,\\\\ -1,&\\text{if }W_{ij}\\leq 0,\\end{cases} \\tag{2}\\]\n' +
      '\n' +
      'and \\(\\alpha\\) is a high-precision scaling factor for the entire matrix. To minimize the quantization error in \\(L_{2}\\) norm:\n' +
      '\n' +
      '\\[\\left\\lVert\\Delta-\\hat{\\Delta}\\right\\rVert^{2}_{2}=\\sum_{ij}\\left(|W_{ij}|- \\alpha\\right)^{2}, \\tag{3}\\]\n' +
      '\n' +
      'we take\n' +
      '\n' +
      '\\[\\alpha=\\frac{1}{nm}\\sum_{ij}|W_{ij}|. \\tag{4}\\]\n' +
      '\n' +
      'Surprisingly, we find that the above quantization approach already does quite well and retains most of the fine-tuned models\' performance.\n' +
      '\n' +
      'Scale distillation.Intuitively, the scaling factor \\(\\alpha\\) plays a more significant role in the low-bit regime. Additionally, per-matrix \\(L_{2}\\) weight error is not a perfect measure of degradation in _overall_ model quality. Thus, we further optimize these scales by performing model distillation to align the output logits of the quantized model to that of the original fine-tuned model. More concretely, we freeze the model weights and optimize for the following objective:\n' +
      '\n' +
      '\\[\\boldsymbol{\\alpha}^{*}=\\arg\\min_{\\boldsymbol{\\alpha}}\\mathbb{E}_{x\\sim \\mathbf{X}}\\left[\\left\\lVert\\mathbf{Z}_{\\text{fine}}(x)-\\mathbf{Z}_{\\text{ bin}}(x;\\boldsymbol{\\alpha})\\right\\rVert^{2}\\right] \\tag{5}\\]\n' +
      '\n' +
      'where \\(\\mathbf{X}\\) is a calibration dataset, and \\(\\mathbf{Z}(\\cdot)\\) are the logits of the respective models. We find that scale distillation is fairly insensitive to choice \\(\\mathbf{X}\\), as 1) the process is extremely parameter efficient, and 2) the crucial aspect of the process is to logit match with the fine-tuned model, regardless of the actual text content.\n' +
      '\n' +
      'For our experiments, we distill on the C4 dataset (Raffel et al., 2023), which is widely used for pre-training, using 800 samples of length 128, and use the Adam optimizer (Kingma & Ba, 2017) with \\(lr=10^{-4}\\), \\(\\beta=(0.9,0.999)\\), \\(\\epsilon=10^{-8}\\). 1x80 GB A100 GPU is used to distill 7B and 13B models, and 6x80GB A100 GPUs are used to distill 70B models (2x for finetune, 4x for binarized). We find that scale distillation is extremely fast; we can compress 70B models in roughly 10 minutes, whereas methods like GPTQ (Frantar et al., 2022) and AWQ (Lin et al., 2023) take multiple hours.\n' +
      '\n' +
      '### Implication\n' +
      '\n' +
      'The ability to compress the delta to merely 1-bit opens up multiple opportunities for improving efficiency, enabling more effective model storage (Isik et al., 2023) - where a single base model can be maintained alongside multiple compressed deltas - and facilitating model hot-swapping (Chen et al., 2023; Sheng et al., 2023). With hot-swapping, the base model remains in GPU memory, and compressed deltas are dynamically loaded in accordance to incoming requests. In both cases, the compression ratio can be directly translated into reductions in storage needs and loading times.\n' +
      '\n' +
      'Moreover, BitDelta enables the possibility of a multi-tenant serving system like Punica (Chen et al., 2023) or S-LoRA (Sheng et al., 2023) but for general fine-tuned models instead of just LoRA models. Concretely, we consider the scenario where multiple models fine-tuned from the same base model are served with the same server. This setting greatly exploits the GPU resource and saves each fine-tuned model\'s inference cost when their traffic is low or unbalanced. With BitDelta, we can keep one high-precision base model with multiple compressed deltas in the GPU memory. Compared to directly serving multiple fine-tuned models, this approach greatly saves memory consumption.\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l c c c c c} \\hline \\hline Model/Method & Train Loss & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\\(\\dagger\\)\\(\\uparrow\\) \\\\ \\hline _Llama 2-7B_ & – & 38.96 & 13.57 & – & 60.53 \\\\ \\hline _Vicuna-7B v1.5_ & – & 50.36 & 19.03 & 6.04 & 60.51 \\\\ \\hline BitDelta-Initial & 0.41 & 47.63 & 19.56 & 5.67 & 60.99 \\\\ BitDelta & 0.052 & 49.97 & 20.17 & 5.99 & 60.68 \\\\ \\hline SVD-Initial & 0.78 & 44.56 & 15.92 & 4.45 & 60.60 \\\\ SVD & 0.34 & 44.55 & 14.18 & 4.98 & 60.20 \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 1: Comparison between BitDelta and a SVD based method (\\(r=16\\)), with _Llama 2-7B_ and _Vicuna-7B v1.5_ as the base and fine-tuned models. BitDelta is performant across the board, whereas the SVD-based method fails to sufficiently capture the fine-tuned information.\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l l c c c c} \\hline \\hline Model & Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\\({}^{\\dagger}\\uparrow\\) \\\\ \\hline _Llama 2-7B_ & – & 38.96 & 13.57 & – & 60.53 \\\\ \\hline \\multirow{3}{*}{_Llama 2-7B Chat_} & Baseline & 45.32 & 22.74 & 6.56 & 59.81 \\\\  & BitDelta-Initial & 41.10 & 18.27 & 6.31 & 60.7 \\\\  & BitDelta & 44.95 & 20.24 & 6.47 & 59.88 \\\\ \\hline \\multirow{3}{*}{_Vicuna-7B v1.5 16k_} & Baseline & 50.38 & 14.18 & 6.06 & 57.50 \\\\  & BitDelta-Initial & 45.58 & 13.95 & 5.69 & 58.51 \\\\  & BitDelta & 48.75 & 14.48 & 6.24 & 57.64 \\\\ \\hline \\multirow{3}{*}{_Llama 2-13B_} & – & 36.90 & 22.74 & – & 64.68 \\\\ \\hline \\multirow{3}{*}{_Llama 2-13B Chat_} & Baseline & 43.95 & 33.13 & 6.98 & 63.99 \\\\  & BitDelta-Initial & 41.70 & 33.36 & 7.06 & 64.25 \\\\  & BitDelta & 43.47 & 31.92 & 6.95 & 63.96 \\\\ \\hline \\multirow{3}{*}{_Vicuna-13B v1.5 16k_} & Baseline & 50.38 & 29.72 & 6.90 & 57.5 \\\\  & BitDelta-Initial & 41.7 & 26.76 & 6.60 & 64.25 \\\\  & BitDelta & 48.75 & 28.73 & 6.88 & 57.64 \\\\ \\hline \\multirow{3}{*}{_WizardLM-13B v1.2_} & Baseline & 47.17 & 42.38 & 6.95 & 61.61 \\\\  & BitDelta-Initial & 44.89 & 42.08 & 6.73 & 61.91 \\\\  & BitDelta & 46.67 & 41.62 & 6.93 & 61.86 \\\\ \\hline \\multirow{3}{*}{_Llama 2-70B_} & – & 44.82 & 52.69 & – & 71.81 \\\\ \\hline \\multirow{3}{*}{_Llama 2-70B Chat_} & Baseline & 52.77 & 47.61 & 7.12 & 68.82 \\\\  & BitDelta-Initial & 41.63 & 42.38 & 6.85 & 66.01 \\\\  & BitDelta & 51.37 & 48.82 & 7.06 & 69.14 \\\\ \\hline \\multirow{3}{*}{_Solar-0-70B_} & Baseline & 62.03 & 56.18 & 7.07 & 73.77 \\\\  & BitDelta-Initial & 59.08 & 56.79 & 6.79 & 73.14 \\\\  & BitDelta & 62.03 & 56.63 & 6.82 & 73.57 \\\\ \\hline \\multirow{3}{*}{_Mistral-7B v0.1_} & – & 42.60 & 37.76 & – & 65.98 \\\\ \\hline \\multirow{3}{*}{_Mistral-7B v0.1_} & Baseline & 55.93 & 32.75 & 6.86 & 60.36 \\\\  & BitDelta-Initial & 51.27 & 38.82 & 6.54 & 63.83 \\\\  & BitDelta & 55.23 & 31.54 & 6.43 & 61.10 \\\\ \\hline \\multirow{3}{*}{_Zephyr-7B-\\(\\beta\\)_} & Baseline & 55.12 & 34.34 & 7.18 & 65.22 \\\\  & BitDelta-Initial & 54.53 & 40.26 & 6.70 & 66.12 \\\\  & BitDelta & 58.39 & 31.92 & 7.00 & 66.20 \\\\ \\hline \\multirow{3}{*}{_Dolphin 2.2.1_} & Baseline & 54.02 & 54.28 & 7.36 & 67.31 \\\\  & BitDelta-Initial & 48.14 & 50.27 & 7.10 & 67.58 \\\\ \\cline{1-1}  & BitDelta & 54.91 & 52.84 & 7.20 & 66.97 \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 2: BitDelta works on Llama-2 and Mistral families and on a wide range of model sizes ranging from 7B to 70B parameters. BitDelta works for many types of fine-tuned information, including SFT-based methods, RLHF-based methods, and context extension methods (RoPE scaling). Scale distillation is effective; it raises TruthfulQA/GSM8K scores to within 1-2 points of the baseline fine-tune, and MT-Bench scores to within 0.1-0.2 points.\n' +
      '\n' +
      'Since LLM inference follows the memory-bound computation pattern where the generation latency is proportional to the GPU memory used by the model weights, the lower memory consumption also suggests the opportunity to improve the serving latency. For example, Puncia and S-LoRA exploit LoRA\'s structure and memory saving by developing a CUDA kernel that can efficiently calculate the batched delta-activation product for low rank deltas. Similarly, we decompose the forward pass of each linear layer as follows:\n' +
      '\n' +
      '\\[X_{i}^{\\prime}=W_{\\text{fine},i}X_{i}\\approx W_{\\text{base}}X_{i}+\\underbrace{ \\hat{\\Delta}_{i}X_{i}}_{\\text{Kernel}} \\tag{6}\\]\n' +
      '\n' +
      'where \\(X_{i}\\) and \\(X_{i}^{\\prime}\\) represent input and output features to the \\(i\\)-th fine-tuned model, and the base model weight and the delta are computed separately. For a batch of requests, \\(W_{\\text{base}}X_{i}\\) can be computed with the classic batched GEMM kernel. We implement a fused binary GEMM kernel in Triton (Tillet et al., 2019) that allows us to calculate \\(\\hat{\\Delta}_{i}X\\) in a batched setting while keeping the 1-bit deltas quantized until they are transferred to the GPU cache. This kernel fuses the dequantization operation with the GEMM calculation, reducing the data moving overhead by a large factor.\n' +
      '\n' +
      '## 4 Experiments\n' +
      '\n' +
      '### Setup\n' +
      '\n' +
      'Baselines.Our primary baselines are the original fine-tuned models without compression. We also compare with 8-bit RTN and 4-bit GPTQ (Frantar et al., 2022) on evaluations where we run BitDelta on quantized base models.\n' +
      '\n' +
      'Models and datasets.We benchmark fine-tuned models based on the Llama-2 (Touvron et al., 2023) and Mistral (Jiang et al., 2023) model families: Vicuna, Xwin-LM, Solar-70B, Zephyr, OpenChat 3.5, Dolphin 2.2.1, and OpenOrca (Chiang et al., 2023; Team, 2023; Upstage, 2023; Tunstall et al., 2023; Wang et al., 2023; Hartford, 2023; Mukherjee et al., 2023). We evaluate on eight tasks: MT-Bench, 25-shot ARC Challenge, 5-shot BBH, 10-shot HellaSwag, zero-shot TruthfulQA, zero-shot LAMBADA, zero-shot Winogrande, and 5-shot GSM8K (Zheng et al., 2023; Clark et al., 2018; Suzgun et al., 2022; Zellers et al., 2019; Lin et al., 2022; Paperno et al., 2016; Sakaguchi et al., 2019; Cobbe et al., 2021). We use FastChat (Zheng et al., 2023) to evaluate on MT-Bench, and use 1m-evaluation-harness (Gao et al., 2023) to evaluate on the other tasks. We denote our methodology before scale distillation is applied as BitDelta-Initial.\n' +
      '\n' +
      'We primarily focus on high-margin metrics where fine-tuning is significantly impactful and aggregate the other metrics. See Tables 6 to 9 in the Appendix for full results. BitDelta performs quite well on the aggregated metrics, even outperforming the baseline in many cases. However, it\'s important to contextualize these results with regard to the base model itself, which is also performant on these metrics.\n' +
      '\n' +
      'In such cases, it\'s difficult to attribute performance to our methodology or to the underlying base model. Because of this, we highlight TruthfulQA, GSM8K, and MT-Bench, which base models tend to struggle on, to show that BitDelta accurately preserves fine-tune information.\n' +
      '\n' +
      '### Accurate Quantization\n' +
      '\n' +
      'SVD comparison.We compare BitDelta to a low rank approx. of the weight delta on _Vicuna-7B v1.5_. For the low rank approx., we decompose \\(\\Delta=U\\Sigma V\\) and approximate \\(\\hat{\\Delta}=AB\\) where \\(A=U\\sqrt{\\hat{\\Sigma}}\\), \\(B=\\sqrt{\\hat{\\Sigma}}V\\). During distillation, we treat all entries of the low rank matrices as trainable parameters. We find that the low rank approx. fails to fully capture the fine tune information, and underperforms across the board (Table 1). Interestingly, we find that distillation is not as effective for the low rank approx. compared to BitDelta, though we partly attribute this to the excess of trainable parameters leading to training instability.\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{p{113.8pt} p{227.6pt}} \\hline \\hline\n' +
      '**Prompt** & Please create a slogan about bioenergy that satisfies the following: 1. Make the tone sound casual 2. Embed an advertisement for a company called “FlexPower” 3. Fewer than 10 words. \\\\ \\hline \\multirow{4}{*}{**BitDelta**} & “FlexPower”s groundbreaking bioenergy solution: Produce fuel without compromising food production!” (10 words) \\\\  & This headline is catchy, casual, and highlights the unique selling point of the... \\\\  & **GPT-4 Score: 8** \\\\ \\hline \\multirow{2}{*}{**BitDelta-Initial**} & “FlexPower”s groundbreaking technology unlocks the key to harnessing the power of renewable bioenergy while minimizing ethical concerns” \\\\  & **GPT-4 Score: 4** \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 3: Comparison of model responses from _Zephyr-7B_-\\(\\beta\\) for Question 9 in MT-Bench, a concise advertisement task. BitDelta-Initial is unable to follow the instructions, producing an advertisement that is overly formal and makes no attempt to adhere to the word limit. With the addition of scale distillation, BitDelta successfully produces a concise, catchy advertisement slightly over the word limit. *Prompt slightly modified for clarity.\n' +
      '\n' +
      'Main Results.BitDelta is performant across various model families, across a wide range of model sizes, and across many fine-tuning techniques. We benchmark on Llama-2 and Mistral families, and on models ranging from 7B to 70B parameters. Shown in Table 2, we find that BitDelta is very general and can recover all types of finetune information, including SFT-based methods (Radford et al., 2018) on _Mistral-7B v0.1 Instruct_, RLHF-based methods (Christiano et al., 2023) on _Llama 2 Chat_, and context extension methods (RoPE scaling) (Chen et al., 2023; Press et al., 2022) on _Vicuna-7B v1.5 16k_.\n' +
      '\n' +
      'We note that GSM8K for BitDelta-Initial on _Mistral-7B v0.1 Instruct_ and _Zephyr-7B-\\(\\beta\\)_ is abnormally high; we attribute this to how performant the base model _Mistral-7B v0.1_ is on this task in comparison.\n' +
      '\n' +
      'Scale distillation is effective. Introducing scale distillation raises TruthfulQA and GSM8K scores to within 1-2 points of the baseline fine-tune, and generally raises MT-Bench scores to within 0.1-0.2 points.\n' +
      '\n' +
      'Case Study.We present a sample response from _Zephyr-7B-\\(\\beta\\)_ in Table 3, highlighting the efficacy of scale distillation. BitDelta-Initial does not have a casual tone, and makes no attempt to adhere to the word limit. With the introduction of scale distillation, BitDelta exhibits greater instruction following capabilities, producing a catchy response that slightly exceeds the word limit.\n' +
      '\n' +
      'Quantized base models.Because 8-bit RTN and GPTQ work with 16-bit activations, we can keep the fine-tune weights \\(W_{\\text{fine}}\\) and scaling factors \\(\\alpha\\) in high precision, only quantizing the base weights \\(W_{\\text{base}}\\). As shown in Table 4, we find that BitDelta is still performant when applied to quantized base models.\n' +
      '\n' +
      'We observe that FP16 + \\(\\Delta\\) outperforms GPTQ across the board. In the performance engineering context of multi-tenancy serving, as we add more models, we would rather store a single high precision base model with many 1-bit deltas than store many quantized fine-tuned models. This interesting result implies that the above also holds true in the _model quality_ context of multi-tenancy serving.\n' +
      '\n' +
      'We try using _Llama 2-7B Chat_ as both the base model and fine-tune model, quantizing the base model using GPTQ, and find that we\'re able to outperform baseline GPTQ on many evaluations. We hypothesize this is because we can diffuse 16-bit information into the model through high precision scaling factors, at the cost of including a 1-bit delta.\n' +
      '\n' +
      'Ablation over fidelity of \\(\\Delta\\).By successively applying BitDelta, treating the compressed model from the previous iteration as our base model, we can vary the granularity over the delta, associating it with multiple 1-bit masks. One advantage of doing this is the ability to assign arbitrary scale factors to each 1-bit mask. In contrast, when increasing the bit size, scale factors are implicitly fixed with respect to each other. Figure 3 shows how the TruthfulQA of _Llama 2-7B_ plus an increasingly granular delta approaches that of _Vicuna-7B v1.5_. Full results are in Table 8.\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l l c c c c} \\hline \\hline Base Model & Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\\(\\dagger\\)\\(\\uparrow\\) \\\\ \\hline \\multirow{3}{*}{Baseline} & FP16 & 45.32 & 22.74 & 6.56 & 59.81 \\\\  & INT8 RTN & 45.02 & 22.29 & 6.28 & 59.63 \\\\  & GPTQ & 44.92 & 19.48 & 5.90 & 58.67 \\\\ \\hline \\multirow{3}{*}{_Llama 2-7B_} & FP16 + \\(\\Delta\\) & 44.95 & 20.24 & 6.47 & 59.88 \\\\  & INT8 RTN + \\(\\Delta\\) & 44.71 & 19.86 & 6.16 & 59.85 \\\\ \\cline{1-1}  & GPTQ + \\(\\Delta\\) & 42.52 & 19.94 & 6.02 & 59.22 \\\\ \\hline \\multirow{3}{*}{_Llama 2-7B Chat_} & GPTQ + \\(\\Delta\\) & 44.63 & 22.14 & 6.11 & 59.17 \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 4: We apply BitDelta to _Llama 2-7B Chat_, and find it holds up when the underlying base model is quantized at various levels. FP16 + \\(\\Delta\\) outperforms baseline GPTQ across the board, implying that in terms of model quality, we would rather store a single high-precision base model with many 1-bit deltas than store many quantized fine-tuned models. GPTQ + \\(\\Delta\\) with _Llama 2-7B Chat_ as the base model also outperforms _baseline_ GPTQ on many evaluations, because the delta diffuses 16-bit information through high precision scaling factors.\n' +
      '\n' +
      'Figure 3: As the fidelity of \\(\\Delta\\) increases, the TruthfulQA scores of _Llama 2-7B_ + \\(\\Delta\\) approaches that of _Vicuna-7B v1.5_.\n' +
      '\n' +
      '### Latency Improvement\n' +
      '\n' +
      'To illustrate the idea of translating memory saving into improved latency, we implement a simple Triton kernel for GEMM with a binary matrix and scaling factor, as in BitDelta. We assume there are \\(B\\) fine-tuned models served on the same GPU. For simplicity, we consider the setting where the requests are uniformly distributed, i.e., each model receives one request simultaneously. Following the decomposition in Eq. (6), the kernel is used to compute the batched matrix multiplication between \\(B\\) binary matrices (\\(N\\times M\\)) and \\(B\\) high-precision activations (\\(L\\times N\\)) where \\(N,M\\) are intermediate dimensions and \\(L\\) is the sequence length. We focus on decoding latency as opposed to the prefill latency, as it consumes most of the time. Tokens are generated one by one in decoding, meaning \\(L\\) is always 1.\n' +
      '\n' +
      'Kernel latency.We benchmark the decoding latency of our kernel, a batched linear operation over multiple deltas with a single base model, as in Eq. (6), corresponding to a single linear layer, and compare against naively computing the forward pass separately for each model. We ablate across the batch size and hidden size dimensions and find that our kernel consistently achieves about 2\\(\\times\\) speedup.\n' +
      '\n' +
      'End-to-end latency.We also benchmark the end-to-end decoding latency on _Llama 2-7B_ variants with an input length of 128 (we find the decoding latency is less sensitive to the input length), ablated across the batch size. We find that BitDelta introduces overhead when the batch size is low. However, BitDelta scales better and successfully translates the saved GPU memory to improved decoding latency, starting at \\(B=4\\). This is exacerbated at higher batch sizes, where the naive approach succumbs to out-of-memory issues and BitDelta is still performant.\n' +
      '\n' +
      '## 5 Conclusion and Discussion\n' +
      '\n' +
      'We propose BitDelta, a simple yet effective approach for efficiently quantizing the weight delta arising from fine-tuning in LLMs down to 1 bit. BitDelta encodes the sign bits of the weight delta and a per-weight matrix scaling factor, which is calibrated further through distillation. This allows for representing multiple full-parameter fine-tuned models with one base model and multiple 1-bit deltas, enhancing applications in multi-tenancy serving by reducing GPU memory requirements and improving generation latency. BitDelta is fast and accurate, showcasing minimal performance degradation, and opens new avenues for efficient model deployment and resource utilization in machine learning.\n' +
      '\n' +
      'Future work.We mainly focus on the qualitative evaluation of BitDelta, as quality is the main challenge that most quantization methods struggle with. We show BitDelta can maintain the quality of the original fine-tuned models and further illustrate the idea of how to translate the memory saving into improved latency with a fused kernel. Yet, there is significant room for improvement - our kernel is fairly slow compared to the theoretical limit, considering the small memory footprint of binary matrices. It may also be possible to achieve better model quality by preserving salient weight deltas. Finally, the idea of calibrating certain scale factors through distillation may be applied more generally to PTQ methods. We hope our work motivates future refinement of scale factors, making low-bit quantized LLMs more robust.\n' +
      '\n' +
      'Figure 4: Decoding latency of a linear layer with and without BitDelta. Blue: Naive forward pass with \\(B\\) distinct fine-tuned models. Yellow: Batched forward pass with BitDelta, corresponding to one base model and \\(B\\) 1-bit deltas, utilizing a Triton kernel. Left: Ablation over hidden size, assuming \\(N=M\\) and \\(B=8\\). Right: Ablation over batch size, assuming \\(N=M=8192\\).\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l c c c} \\hline \\hline Base Model & Size & \\(\\Delta\\) Size & Comp. Factor \\\\ \\hline _Llama 2-7B_ & 13.48 GB & 1.24 GB & 10.87 \\\\ _Llama 2-13B_ & 26.03 GB & 2.09 GB & 12.45 \\\\ _Llama 2-70B_ & 137.95 GB & 8.95 GB & 15.41 \\\\ _Mistral-7B v0.1_ & 14.48 GB & 1.30 GB & 11.14 \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 5: BitDelta achieves over 10\\(\\times\\) compression. We can further compress the embedding and LM head layers, but leave this to future work due to inconsistencies in tokenizer vocabularies.\n' +
      '\n' +
      'Figure 5: End-to-end decoding latency of _Llama 2-7B_ variants with and without BitDelta. Blue: Naive forward pass with \\(B\\) distinct fine-tuned models. Orange: Projected values for the naive forward pass. Green: Batched forward pass with BitDelta. The naive forward pass succumbs to GPU memory issues at higher batch sizes, whereas BitDelta is still performant.\n' +
      '\n' +
      '## 6 Impact Statement\n' +
      '\n' +
      'Environmental Sustainability and Cost Reduction.The reduction in GPU memory requirements through BitDelta translates to lower energy consumption and a reduction in costs associated with serving multiple fine-tuned models. By significantly lowering hardware requirements, BitDelta contributes to making AI technologies more eco-friendly and economically viable. This approach aligns with the growing need for sustainable and cost-effective computing solutions in the deployment of large-scale AI technologies.\n' +
      '\n' +
      'Democratization of Fine-tuned Models.By dramatically reducing the hardware requirements for serving fine-tuned models, BitDelta enables smaller entities to deploy state-of-the-art models more feasibly. This can accelerate innovation and application development across various industries and academic fields, making fine-tuned models accessible to a wider audience.\n' +
      '\n' +
      'Dealignment Mitigation.BitDelta is a lossy compression method on the fine-tune information in LLMs. As such, crucial alignment information may be lost in the process of compression. We believe this is an important consequence to highlight, as BitDelta democratizes multi-tenant applications which may exacerbate this dealignment concern. We encourage further work on evaluation techniques to detect alignment loss in BitDelta, which can lead to the creation of robust methods for its mitigation.\n' +
      '\n' +
      '## Acknowledgments\n' +
      '\n' +
      'We thank Together AI, MyShell AI, National Science Foundation (NSF), MIT-IBM Watson AI Lab, and MIT Amazon Science Hub for supporting this research.\n' +
      '\n' +
      '## References\n' +
      '\n' +
      '* E. Beeching, C. Fourrier, N. Habib, S. Han, N. Lambert, N. Rajani, O. Sanseviero, L. Tunstall, and T. Wolf (2023)Open llm leaderboard. Note: [https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard](https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard) Cited by: SS1.\n' +
      '* T. Cai, Y. Li, Z. Geng, H. Peng, J. D. Lee, D. Chen, and T. Dao (2024)Medusa: simple llm inference acceleration framework with multiple decoding heads. arXiv preprint arXiv: 2401.10774. Cited by: SS1.\n' +
      '* J. Chee, Y. Cai, V. Kuleshov, and C. De Sa (2023)Quip: 2-bit quantization of large language models with guarantees. arXiv preprint arXiv:2307.13304. Cited by: SS1.\n' +
      '* C. Chen, S. Borgeaud, G. Irving, J. Lespiau, L. Sifre, and J. Jumper (2023)Accelerating large language model decoding with speculative sampling. February 2023a. doi: 10.48550/ARXIV.2302.01318. Cited by: SS1.\n' +
      '* G. Chen, F. Liu, Z. Meng, and S. Liang (2022)Revisiting parameter-efficient tuning: are we really there yet?. Cited by: SS1.\n' +
      '* L. Chen, Z. Ye, Y. Wu, D. Zhuo, L. Ceze, and A. Krishnamurthy (2023)Punica: multi-tenant lora serving. External Links: 2023b. Cited by: SS1.\n' +
      '* S. Chen, S. Wong, L. Chen, and Y. Tian (2023)Extending context window of large language models via positional interpolation. External Links: 2307.13304 Cited by: SS1.\n' +
      '* Y. Chen, S. Qian, H. Tang, X. Lai, Z. Liu, S. Han, and J. Jia (2023)Longlora: efficient fine-tuning of long-context large language models. External Links: 2307.13304 Cited by: SS1.\n' +
      '* W. Chiang, Z. Li, Z. Lin, Y. Sheng, Z. Wu, H. Zhang, L. Zheng, S. Zhuang, Y. Zohuang, J. E. Gonzalez, I. Stoica, and E. P. Xing (2023)Vicuna: an open-source chatbot impressing gpt-4 with 90%* chatpt quality. External Links: 2307.13304 Cited by: SS1.\n' +
      '* P. Christiano, J. Leike, T. B. Brown, M. Martic, S. Legg, and D. Amodei (2023)Deep reinforcement learning from human preferences. External Links: 2307.13304 Cited by: SS1.\n' +
      '* P. Clark, I. Cowhey, O. Etzioni, T. Khot, A. Sabharwal, C. Schoenick, and O. Tafjord (2018)Think you have solved question answering? try arc, the ai2 reasoning challenge. External Links: 1803.06615 Cited by: SS1.\n' +
      '* K. Cobbe, V. Kosaraju, M. Bavarian, M. Chen, H. Jun, L. Kaiser, M. Plappert, J. Tworek, J. Hilton, R. Nakano, et al. (2021)Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168. Cited by: SS1.\n' +
      '* T. Dettmers, M. Lewis, Y. Belkada, and L. Zettlemoyer (2022)Llm. int8 (0): 8-bit matrix multiplication for transformers at scale. arXiv preprint arXiv:2208.07339. Cited by: SS1.\n' +
      '* T. Dettmers, A. Pagnoni, A. Holtzman, and L. Zettlemoyer (2023)Qlora: efficient finetuning of quantized llms. arXiv preprint arXiv:2305.14314. Cited by: SS1.\n' +
      '* J. Devlin, M. Chang, K. Lee, and K. Toutanova (2019)Bert: pre-training of deep bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pp. 4171-4186. Cited by: SS1.\n' +
      '\n' +
      '[MISSING_PAGE_POST]\n' +
      '\n' +
      '* Frantar et al. (2022) Frantar, E., Ashkboos, S., Hoefler, T., and Alistarh, D. Gptq: Accurate post-training quantization for generative pre-trained transformers. _arXiv preprint arXiv:2210.17323_, 2022.\n' +
      '* Gao et al. (2023) Gao, L., Tow, J., Abbasi, B., Biderman, S., Black, S., DiPofi, A., Foster, C., Golding, L., Hsu, J., Le Noac\'h, A., Li, H., McDonell, K., Muennighoff, N., Ociepa, C., Phang, J., Reynolds, L., Schoelkopf, H., Skowron, A., Sutawika, L., Tang, E., Thite, A., Wang, B., Wang, K., and Zou, A. A framework for few-shot language model evaluation, 12 2023. URL [https://zenodo.org/records/10256836](https://zenodo.org/records/10256836).\n' +
      '* Han et al. (2015) Han, S., Pool, J., Tran, J., and Dally, W. J. Learning both weights and connections for efficient neural networks, 2015.\n' +
      '* Han et al. (2016) Han, S., Mao, H., and Dally, W. J. Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding, 2016.\n' +
      '* Hartford (2023) Hartford, E. Cognitivecomputations/dolphin-2.2.1-mistral-7b, hugging face, 2023. URL [https://huggingface.co/cognitivecomputations/dolphin-2.2.1-mistral-7b](https://huggingface.co/cognitivecomputations/dolphin-2.2.1-mistral-7b).\n' +
      '* Houlsby et al. (2019) Houlsby, N., Giurgiu, A., Jastrzebski, S., Morrone, B., De Laroussilhe, Q., Gesmundo, A., Attariyan, M., and Gelly, S. Parameter-efficient transfer learning for nlp. In _International Conference on Machine Learning_, pp. 2790-2799. PMLR, 2019a.\n' +
      '* Houlsby et al. (2019) Houlsby, N., Giurgiu, A., Jastrzebski, S., Morrone, B., de Laroussilhe, Q., Gesmundo, A., Attariyan, M., and Gelly, S. Parameter-efficient transfer learning for nlp, 2019b.\n' +
      '* Hu et al. (2021) Hu, E. J., Shen, Y., Wallis, P., Allen-Zhu, Z., Li, Y., Wang, S., and Chen, W. Lora: Low-rank adaptation of large language models. _ICLR_, 2021.\n' +
      '* Isik et al. (2023) Isik, B., Kumbong, H., Ning, W., Yao, X., Koyejo, S., and Zhang, C. GPT-zip: Deep compression of finetuned large language models. In _Workshop on Efficient Systems for Foundation Models @ ICML2023_, 2023. URL [https://openreview.net/forum?id=h00C2tG2xL](https://openreview.net/forum?id=h00C2tG2xL).\n' +
      '* Jiang et al. (2023) Jiang, A. Q., Sablayrolles, A., Mensch, A., Bamford, C., Chaplot, D. S., de las Casas, D., Bressand, F., Lengyel, G., Lample, G., Saulnier, L., Lavaud, L. R., Lachaux, M.-A., Stock, P., Scao, T. L., Lavril, T., Wang, T., Lacroix, T., and Sayed, W. E. Mistral 7b, 2023.\n' +
      '* Jin et al. (2023) Jin, X., Ren, X., Preotiuc-Pietro, D., and Cheng, P. Dataless knowledge fusion by merging weights of language models, 2023.\n' +
      '* Kim et al. (2023) Kim, S., Hooper, C., Gholami, A., Dong, Z., Li, X., Shen, S., Mahoney, M. W., and Keutzer, K. Squeezellm: Dense-and-sparse quantization. _arXiv preprint arXiv:2306.07629_, 2023.\n' +
      '* Kingma & Ba (2017) Kingma, D. P. and Ba, J. Adam: A method for stochastic optimization, 2017.\n' +
      '* LeCun et al. (1989) LeCun, Y., Denker, J., and Solla, S. Optimal brain damage. In Touretzky, D. (ed.), _Advances in Neural Information Processing Systems_, volume 2. Morgan-Kaufmann, 1989. URL [https://proceedings.neurips.cc/paper_files/paper/1989/file/6c9882bbac1c7093bd25041881277658-Paper.pdf](https://proceedings.neurips.cc/paper_files/paper/1989/file/6c9882bbac1c7093bd25041881277658-Paper.pdf).\n' +
      '* Leviathan et al. (2022) Leviathan, Y., Kalman, M., and Matias, Y. Fast inference from transformers via speculative decoding. November 2022. doi: 10.48550/ARXIV.2211.17192.\n' +
      '* Lin et al. (2023) Lin, J., Tang, J., Tang, H., Yang, S., Dang, X., and Han, S. Awq: Activation-aware weight quantization for llm compression and acceleration. _arXiv preprint arXiv:2306.00978_, 2023.\n' +
      '* Lin et al. (2022) Lin, S., Hilton, J., and Evans, O. Truthfulqa: Measuring how models mimic human falsehoods, 2022.\n' +
      '* Mishra et al. (2021) Mishra, A., Latorre, J. A., Pool, J., Stosic, D., Stosic, D., Venkatesh, G., Yu, C., and Micikevicius, P. Accelerating sparse deep neural networks. _arXiv preprint arXiv: 2104.08378_, 2021.\n' +
      '* Mukherjee et al. (2023) Mukherjee, S., Mitra, A., Jawahar, G., Agarwal, S., Palangi, H., and Awadallah, A. Orca: Progressive learning from complex explanation traces of gpt-4, 2023.\n' +
      '* Niederfahrenhorst et al. (2023) Niederfahrenhorst, A., Hakhamaneshi, K., and Ahmad, R. Fine-tuning llms: In-depth analysis with llama-2, Sep 2023. URL [https://www.anyscale.com/blog/fine-tuning-lms-lora-or-full-parameter-an-in-depth-analysis-with-llama-2](https://www.anyscale.com/blog/fine-tuning-lms-lora-or-full-parameter-an-in-depth-analysis-with-llama-2).\n' +
      '* Ouyang et al. (2022) Ouyang, L., Wu, J., Jiang, X., Almeida, D., Wainwright, C. L., Mishkin, P., Zhang, C., Agarwal, S., Slama, K., Ray, A., et al. Training language models to follow instructions with human feedback. _arXiv preprint arXiv:2203.02155_, 2022.\n' +
      '* Paperno et al. (2016) Paperno, D., Kruszewski, G., Lazaridou, A., Pham, Q. N., Bernardi, R., Pezzelle, S., Baroni, M., Boleda, G., and Fernandez, R. The lambda dataset: Word prediction requiring a broad discourse context, 2016.\n' +
      '* Press et al. (2022) Press, O., Smith, N. A., and Lewis, M. Train short, test long: Attention with linear biases enables input length extrapolation, 2022.\n' +
      '\n' +
      'Qiu, J., Li, L., Sun, J., Peng, J., Shi, P., Zhang, R., Dong, Y., Lam, K., Lo, F. P.-W., Xiao, B., Yuan, W., Wang, N., Xu, D., and Lo, B. Large ai models in health informatics: Applications, challenges, and the future. _IEEE Journal of Biomedical and Health Informatics_, 27(12):6074-6087, 2023. doi: 10.1109/JBHI.2023.3316750.\n' +
      '* Radford et al. (2018) Radford, A., Narasimhan, K., Salimans, T., and Sutskever, I. Improving language understanding by generative pretraining. 2018.\n' +
      '* Radford et al. (2019) Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., Sutskever, I., et al. Language models are unsupervised multitask learners. _OpenAI blog_, 1(8):9, 2019.\n' +
      '* Raffel et al. (2023) Raffel, C., Shazeer, N., Roberts, A., Lee, K., Narang, S., Matena, M., Zhou, Y., Li, W., and Liu, P. J. Exploring the limits of transfer learning with a unified text-to-text transformer, 2023.\n' +
      '* Rebuffi et al. (2017) Rebuffi, S.-A., Bilen, H., and Vedaldi, A. Learning multiple visual domains with residual adapters. _Advances in neural information processing systems_, 30, 2017.\n' +
      '* Sakaguchi et al. (2019) Sakaguchi, K., Bras, R. L., Bhagavatula, C., and Choi, Y. Winogrande: An adversarial winograd schema challenge at scale, 2019.\n' +
      '* Sheng et al. (2023) Sheng, Y., Cao, S., Li, D., Hooper, C., Lee, N., Yang, S., Chou, C., Zhu, B., Zheng, L., Keutzer, K., Gonzalez, J. E., and Stoica, I. S-Iora: Serving thousands of concurrent lora adapters. _arXiv preprint arXiv:2311.03285_, 2023.\n' +
      '* Suzgun et al. (2022) Suzgun, M., Scales, N., Scharli, N., Gehrmann, S., Tay, Y., Chung, H. W., Chowdhery, A., Le, Q. V., Chi, E. H., Zhou, D., et al. Challenging big-bench tasks and whether chain-of-thought can solve them. _arXiv preprint arXiv:2210.09261_, 2022.\n' +
      '* Team (2023) Team, X.-L. Xwin-lm, 9 2023. URL [https://github.com/Xwin-LM/Xwin-LM](https://github.com/Xwin-LM/Xwin-LM).\n' +
      '* Tillet et al. (2019) Tillet, P., Kung, H.-T., and Cox, D. D. Triton: an intermediate language and compiler for tiled neural network computations. _Proceedings of the 3rd ACM SIGPLAN International Workshop on Machine Learning and Programming Languages_, 2019. URL [https://api.semanticscholar.org/CorpusID:184488182](https://api.semanticscholar.org/CorpusID:184488182).\n' +
      '* Touvron et al. (2023) Touvron, H., Martin, L., Stone, K., Albert, P., Almahairi, A., Babaei, Y., Bashlykov, N., Batra, S., Bhargava, P., Bhosale, S., et al. Llama 2: Open foundation and fine-tuned chat models. _arXiv preprint arXiv:2307.09288_, 2023.\n' +
      '* Tunstall et al. (2023) Tunstall, L., Beeching, E., Lambert, N., Rajani, N., Rasul, K., Belkada, Y., Huang, S., von Werra, L., Fourrier, C., Habib, N., Sarrazin, N., Sanseviero, O., Rush, A. M., and Wolf, T. Zephyr: Direct distillation of lm alignment, 2023.\n' +
      '* Upstage (2023) Upstage/solar-0-70b-16bit. hugging face, 2023. URL [https://huggingface.co/upstage/](https://huggingface.co/upstage/) SOLAR-0-70b-16bit.\n' +
      '* Wang et al. (2023) Wang, G., Cheng, S., Zhan, X., Li, X., Song, S., and Liu, Y. Openchat: Advancing open-source language models with mixed-quality data, 2023.\n' +
      '* Wortsman et al. (2022) Wortsman, M., Ilharco, G., Gadre, S. Y., Roelofs, R., Gontijo-Lopes, R., Morcos, A. S., Namkoong, H., Farhadi, A., Carmon, Y., Kornblith, S., and Schmidt, L. Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time, 2022.\n' +
      '* Xiao et al. (2023) Xiao, G., Lin, J., Seznec, M., Wu, H., Demouth, J., and Han, S. Smoothquant: Accurate and efficient post-training quantization for large language models. In _International Conference on Machine Learning_, pp. 38087-38099. PMLR, 2023.\n' +
      '* Xu et al. (2024) Xu, M., Du, H., Niyato, D., Kang, J., Xiong, Z., Mao, S., Han, Z., Jamalipour, A., Kim, D. I., Shen, X., Leung, V. C. M., and Poor, H. V. Unleashing the power of edge-cloud generative ai in mobile networks: A survey of aigc services. _IEEE Communications Surveys & Tutorials_, pp. 1-1, 2024. doi: 10.1109/COMST.2024.3353265.\n' +
      '* Yao & Klimovic (2023) Yao, X. and Klimovic, A. Deltazip: Multi-tenant language model serving via delta compression. _arXiv preprint arXiv:2312.05215_, 2023.\n' +
      '* Yu et al. (2023) Yu, L., Yu, B., Yu, H., Huang, F., and Li, Y. Language models are super mario: Absorbing abilities from homologous models as a free lunch. _arXiv preprint arXiv:2311.03099_, 2023.\n' +
      '* Zellers et al. (2019) Zellers, R., Holtzman, A., Bisk, Y., Farhadi, A., and Choi, Y. Hellaswag: Can a machine really finish your sentence?, 2019.\n' +
      '* Zheng et al. (2023) Zheng, L., Chiang, W.-L., Sheng, Y., Zhuang, S., Wu, Z., Zhuang, Y., Lin, Z., Li, Z., Li, D., Xing, E. P., Zhang, H., Gonzalez, J. E., and Stoica, I. Judging llm-as-a-judge with mt-bench and chatbot arena, 2023.\n' +
      '* Zhu & Gupta (2017) Zhu, M. and Gupta, S. To prune, or not to prune: exploring the efficacy of pruning for model compression. _International Conference on Learning Representations_, 2017.\n' +
      '\n' +
      '[MISSING_PAGE_EMPTY:12]\n' +
      '\n';
  </script>
  <style>
    #content {
      max-width: 800px;
      margin: auto;
    }
  </style>
  <script>
    let script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/mathpix-markdown-it@1.0.40/es5/bundle.js";
    document.head.append(script);

    script.onload = function() {
      const isLoaded = window.loadMathJax();
      if (isLoaded) {
        console.log('Styles loaded!')
      }

      const el = window.document.getElementById('content-text');
      if (el) {
        const options = {
          htmlTags: true
        };
        const html = window.render(text, options);
        el.outerHTML = html;
      }
    };
  </script>
</head>
<body>
  <div id="content"><div id="content-text"></div></div>
</body>
</html>