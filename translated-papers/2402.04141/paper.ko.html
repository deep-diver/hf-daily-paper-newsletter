<!DOCTYPE html>
<html lang="en" data-lt-installed="true"><head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    const text = '' +
      '# 멀티라인 AI 보조 코드 저작\n' +
      '\n' +
      'Omer Dunay\n' +
      '\n' +
      'omerdu@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 캘리포니아 멘로파크\n' +
      '\n' +
      ' 다니엘 쳉\n' +
      '\n' +
      'danielcheng@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 워싱턴주 벨뷰\n' +
      '\n' +
      ' 아담 테이트\n' +
      '\n' +
      'adamtait@meta.com\n' +
      '\n' +
      '(주)메타플랫폼\n' +
      '\n' +
      'USA\n' +
      '\n' +
      ' 파스 타카르\n' +
      '\n' +
      'parthdt@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 캘리포니아 멘로파크\n' +
      '\n' +
      ' 피터 C. 릭비\n' +
      '\n' +
      'prc@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      'USA\n' +
      '\n' +
      ' 앤디 치우\n' +
      '\n' +
      'achiu@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      'USA\n' +
      '\n' +
      ' 이미드 아흐마드\n' +
      '\n' +
      'imadahmad@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 캘리포니아 멘로파크\n' +
      '\n' +
      ' 아룬 가네산\n' +
      '\n' +
      'arunganesan@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      'USA\n' +
      '\n' +
      ' 산드라 매딜라\n' +
      '\n' +
      'cmaddila@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 워싱턴주 벨뷰\n' +
      '\n' +
      ' 비자야라거브 무랄리\n' +
      '\n' +
      'viajmurali@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '미국 캘리포니아 멘로파크\n' +
      '\n' +
      ' 알리타예비\n' +
      '\n' +
      'alitayyebi@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      '뉴욕, 뉴욕, 미국\n' +
      '\n' +
      ' 나치 나가판\n' +
      '\n' +
      'nnachi@meta.com\n' +
      '\n' +
      '(주)메타플랫폼스\n' +
      '\n' +
      'USA\n' +
      '\n' +
      '###### Abstract.\n' +
      '\n' +
      'CodeCompose는 메타의 개발자 수만 명에게 인라인 제안을 제공하는 대규모 언어 모델(LLM)로 구동되는 AI 지원 코드 저작 도구이다. 본 논문에서는 단일 라인 제안에서 다중 라인 제안으로 제품을 확장하는 방법을 제시한다. 이러한 진화는 개발자에게 이러한 제안의 유용성을 개선하는 데 있어 몇 가지 고유한 문제를 극복해야 했다.\n' +
      '\n' +
      '먼저, LLM의 제안이 개발자의 기존 코드를 지속적으로 이동하므로 생산성 및 만족도가 저하될 수 있으므로 다중 라인 제안이 "jarring" 효과를 가질 수 있는 방법에 대해 논의한다.\n' +
      '\n' +
      '둘째, 다중 라인 제안은 생성 시간이 상당히 오래 걸리기 때문에 사용자가 지각하는 대기 시간을 줄이기 위해 몇 가지 혁신적인 투자를 제시한다. 이러한 모델 호스팅 최적화는 다중 라인 제안 대기 시간을 2.5배 단축했습니다.\n' +
      '\n' +
      '마지막으로, 10명의 엔지니어들을 대상으로 실험을 수행하여 다중 라인 제안이 사용자 경험에 어떤 영향을 미치는지 이해하고 이를 단일 라인 제안과 대조한다. 실험을 통해 (i) 다중 라인 제안이 수락된 전체 문자의 42%(표시된 제안의 경우 16%만을 차지함에도 불구하고) 다중 라인 제안이 사용자를 위해 저장된 키 입력 비율을 9%에서 17%로 거의 두 배로 증가시켰음을 알 수 있다. 멀티라인 코드콤포즈는 메타에서 모든 엔지니어에게 출시되었으며, 1% 미만의 엔지니어가 멀티라인 제안에서 선택하지 않았습니다.\n' +
      '\n' +
      '+\n' +
      '각주 †: 릭비는 캐나다 QC 몬트리올에 있는 콩코디아 대학의 교수입니다.\n' +
      '\n' +
      '+\n' +
      '각주 †: 릭비는 캐나다 QC 몬트리올에 있는 콩코디아 대학의 교수입니다.\n' +
      '\n' +
      '+\n' +
      '각주 †: 릭비는 캐나다 QC 몬트리올에 있는 콩코디아 대학의 교수입니다.\n' +
      '\n' +
      '+\n' +
      '각주 †: 릭비는 캐나다 QC 몬트리올에 있는 콩코디아 대학의 교수입니다.\n' +
      '\n' +
      '+\n' +
      '각주 †: 릭비는 캐나다 QC 몬트리올에 있는 콩코디아 대학의 교수입니다.\n' +
      '\n' +
      '## 1. Introduction\n' +
      '\n' +
      'CodeCompose[(15)]는 소프트웨어 엔지니어가 코드를 유형화할 때 인라인 제안을 제공하지만 원래는 현재 라인을 완성할 토큰을 예측하도록 설계되었다. 이러한 단일 라인 제안은 빠르고 정확하며 즉각적인 맥락에 도움이 되어야 한다. 대조적으로, 다중 라인 제안은 깊이 있고 지능적일 필요가 있다. 이러한 코드 블록은 사용자가 API, 모범 사례 및 구현 세부 정보를 발견하는 데 도움이 될 수 있습니다. 본 연구에서는 코드컴포즈에 멀티라인 제안을 추가한 방법에 대해 기술한다.\n' +
      '\n' +
      '코드콤포즈는 사용자 유형으로 코드를 제안하여 주요 저작 워크플로우에 영향을 미칩니다. 다중-라인 제안들은 디스플레이된 제안들이 사용자가 이미 작성한 코드를 중심으로 이동함에 따라 "jarring" 효과를 가질 수 있다. 제안된 코드와 인간이 작성한 코드의 혼합은 신뢰하고 작성한 코드를 검증해야 하는 코드로 검토하고 재작업해야 하기 때문에 사용자에게 인지 부하가 높다. 우리는 침입하지 않고 기존 사용자 경험에 매끄럽게 피팅하는 엄격한 디자인 원칙을 준수했습니다.\n' +
      '\n' +
      '멀티라인 제안의 개발에는 크게 세 가지 과제가 있었다: (1) jarring 효과를 제거하는 것 (2) 생성하고자 하는 큰 코드 블록에 대해 낮은 지연 시간을 갖는 응답적인 제안을 제공하는 것 (3) 롤아웃 및 10만 명의 개발자에게 멀티라인의 영향을 평가하는 것.\n' +
      '\n' +
      '**챌린지 1. 사용자 인터페이스 경험 - "jarring" 효과 제거**\n' +
      '\n' +
      '"jarring" 효과를 피하는 것은 단일 선 제안으로 간단합니다. 커서가 선 끝에 있을 때(괄호처럼 끝에 특수 문자를 제외하고) 제안만 표시합니다. 대조적으로, 다중 라인은 이미 쓰여진 코드를 방해할 수 있기 때문에 복잡하다. 이 솔루션에 대한 알고리즘을 만드는 것은 커서의 컨텍스트를 확실하게 결정하는 방법을 파악하는 것을 포함하여 자명하지 않은 기술적 문제를 제기한다. 더욱이 LLM으로부터의 응답들은 잘 포맷되지 않을 수 있고, 그것들을 커서 위치에 정렬시키는 것은 사용자에 대한 추가적인 산만함을 야기할 수 있다.\n' +
      '\n' +
      'CodeCompose는 프로그래밍 언어 및 커서 위치 범위에 대한 의미적 컨텍스트 이해를 활용하는 사전-프로세싱 및 사후-프로세싱 알고리즘의 조합으로 이러한 과제를 처리한다. 섹션 3에서는 사용자에게 노이즈를 최소화하기 위해 의미 범위를 기반으로 하는 이 다중 라인 알고리즘에 대해 논의한다.\n' +
      '\n' +
      '**챌린지 2. 반응형 사용자 경험**\n' +
      '\n' +
      '코드콤포즈의 인라인 제안은 사용자 유형에 따라 자동으로 나타납니다. 각 제안은 활성 파일의 주어진 상태와 정렬되며, 사용자가 추가 키 입력을 입력하거나 커서를 이동하자마자 무효화되고 있다. 다중-라인 제안들은 본질적으로 길기 때문에, LLM이 그것들을 생성하는 데 몇 초가 걸릴 수 있고, 그 시간 동안 사용자는 다른 키 스트로크를 타격하고 그들이 제안을 보기도 전에 응답을 무시할 수 있다.\n' +
      '\n' +
      '레이턴시는 "디스플레이 레이트", 즉 사용자가 실제로 볼 수 있는 제안의 수를 결정하는 핵심 요소이기 때문에 섹션 4에 요약된 바와 같이 클라이언트 확장 및 모델 호스팅 서비스 모두를 통해 긴 다중 라인 제안의 레이턴시를 줄이는 데 투자했다.\n' +
      '\n' +
      '**챌린지 3. 생산 릴리즈 및 유효성 측정**\n' +
      '\n' +
      '우리가 직면한 마지막 과제는 이전 섹션에서 열거된 실험 기능의 효과를 모니터링하는 것이었다. 각 기능이 사용자 경험을 개선하는지 여부를 평가하기 위해 온라인에서 수많은 메트릭을 추적하고 그에 따라 제품을 조정했다. 특히, 사용자들이 단일 라인 제안들에 비해 다중 라인 제안들의 더 높은 지연 시간 및 감소된 디스플레이 레이트로 인해 더 유용한 것을 발견했는지 여부를 평가할 필요가 있었다.\n' +
      '\n' +
      '이러한 메트릭에는 수용률, 표시 속도, 대기 시간, 저장된 % 키 입력 및 사용자당 허용되는 문자 #이 포함되었다. 이를 단일 라인 대 다중 라인 제안으로 세분화하여 사용자별 각 기능의 순편익을 결정했다.\n' +
      '\n' +
      '결과 요약** 온라인 A/B 테스트를 모니터링 할 때, 우리는 다중 라인 제안에 대한 투자가 처리량을 불균형적으로 증가시킨다는 것을 발견했다.\n' +
      '\n' +
      '* 다중 라인 제안은 합격일 총 문자의 42%(표시된 제안의 16%만을 차지함에도 불구하고)를 차지했다.\n' +
      '* 다중 라인 제안은 표 1에서 볼 수 있듯이 9%에서 17%로 절약된 % 키스트로크에서 상당한 순 증가를 견인했다.\n' +
      '\n' +
      '본 논문은 다음과 같이 구성되어 있다. 섹션 2에서 메타에 대한 배경을 제공하고 실험 방법론을 소개한다. 섹션 3에서 5에서 각 문제를 해결한다. 섹션 6에서는 유효성에 대한 위협에 대해 논의한다. 7절과 8절에서는 관련 작업을 논의하고 논문을 마무리한다.\n' +
      '\n' +
      '##2. 배경 및 방법론\n' +
      '\n' +
      '### Meta\n' +
      '\n' +
      '메타는 소셜 네트워킹 및 가상 현실에서 지속적인 통합 툴링 및 작업장 조정과 같은 소프트웨어 엔지니어링 인프라에 이르기까지 광범위한 응용 프로그램을 포괄하는 복잡한 코드 기반을 가진 주요 산업 소프트웨어 조직이다. 수천 명의 개발자가 수십 개의 프로그래밍 언어로 작성된 소스 코드를 포함하는 모놀리식 저장소에서 수십억 개의 코드 라인(LOC)을 작업한다. 메타에서 코드 저작은 소프트웨어 개발 수명 주기(SDLC)에서 두드러진 활동 중 하나이다. 내부 소프트웨어 개발 프로세스 및 라이브러리에 대한 상당한 양의 상황 지식은 소스 코드에 포함되거나 소규모 개발자 집합에 국한된다. 예를 들어, _"Hack의 Hive로부터 테이블을 어떻게 질의할 수 있는가?"_와 같은 질문이 그 지식을 이용하여 답변될 수 있다. 소스 코드의 상태와 소스 코드와 연관된 개발자들은 끊임없는 진화의 상태에 있다 - 내부 프레임워크와 도구가 추가되고 비난받는 반면, 개발자들은 팀을 가로질러 이동하고 역할을 변경한다. 메타의 규모에서 코딩 작업을 수행하는 데 필요한 지식을 따라잡는 것은 주요 과제이다. 또한 메타와 같은 대형 소프트웨어 회사의 동적 환경은 지식 발견과 개발자 생산성 향상에 몇 가지 과제를 제기한다.\n' +
      '\n' +
      '메타에서 #### 코드컴포지션\n' +
      '\n' +
      '메타에서는 코드 저작을 위한 LLM 기술의 적용을 탐색하기 위해 CodeCompose라는 AI 보조 코드 저작 시스템을 구축하였다(Codera et al., 2018). 우리 팀은 기본 LLM 아키텍처에 대한 R&D를 수행하고 코드콤포즈의 초기 버전에 대한 기본 모델로 InCode7-6.7B(Dwork et al., 2018)를 사용하여 수렴했다. 최근에는 CodeLlama(Dwork et al., 2018)의 출시와 함께 CodeLlama-7B의 미세 조정 버전을 기초 모델로 사용하는 것으로 전환하였다.\n' +
      '\n' +
      '코드콤포즈는 인라인 제안 경험을 위한 몇 가지 바람직한 특징을 가지고 있다. (i) 코드라마의 다양한 프로그래밍 언어에 대한 훈련으로 인해, (ii) 메타에 맞춤화된, 코드라마의 조직별 데이터에 대한 내부 미세 조정 결과, (iii) 인라인 코드 코멘트를 생성하고 이해할 수 있는 능력을 제공하는 자연어 능력, (iv) 제안 생성 시 커서의 앞뒤를 모두 볼 수 있는 FIM(fill-in-the-middle) 훈련으로 인해, 양방향성을 제공한다.\n' +
      '\n' +
      'CodeCompression을 평가하기 위한### 측정\n' +
      '\n' +
      'CodeCompose를 평가하기 위해 다음과 같은 척도를 사용했다.\n' +
      '\n' +
      '*# 하루 사용자당 표시되는 제안사항\n' +
      '* 제안 생성 및 표시의 E2E 레이턴시\n' +
      '* 수락률(# 수락/#? 750ms 동안 사용자에게 보여지는 제안들에 대해 표시됨)\n' +
      '* #1일 사용자당 허용된 차트\n' +
      '* % 키 입력이 저장된 저장(# chars accepted/# of chars typed by user)\n' +
      '\n' +
      '우리는 이러한 메트릭을 깔때기로 생각하며, 제안들이 맨 위에 표시되어, 수락된 제안들의 처리량을 증가시키고, 저장된 키 입력의 총 %를 증가시킨다. 지연은 가드레일 메트릭 역할을 하지만 지연 시간이 짧을수록 표시되는 제안의 #이 증가하기 때문에 이 깔때기에 공급됩니다.\n' +
      '\n' +
      'Meta에서, 변경들은 무작위 이중 블라인드 시험들, _i.e._ A/B 시험들에서 롤아웃된다(Krishnan et al., 2017). 섹션 5의 전체적 사용자 경험에 대한 각 새로운 다중 라인 기능의 효과를 평가하기 위해 각 롤아웃에 대한 설정을 설명한다.\n' +
      '\n' +
      '##3. 어드레싱 도전 1\n' +
      '\n' +
      '_User 인터페이스 경험 - "jarring" effect__\n' +
      '\n' +
      '이 섹션에서는 메타와 같은 대규모 산업 조직 내에서 다중 라인 제안이 가능한 코딩 어시스턴트를 배치하는 것과 관련된 고유한 도전과 고려 사항을 탐구한다. 이러한 통찰력은 코드콤포즈를 얼리 어답터로 사용하던 수백 명의 사용자로부터 받은 피드백에서 도출된다. 초기 직관과 달리, 멀티 라인 유스 케이스는 제품 관점 및 기술적 구현 관점 모두에서 단일 라인 유스 케이스에 비해 더 높은 수준의 복잡성을 나타낸다. 각 사용 사례에 대한 주요 목표는 다음과 같습니다.\n' +
      '\n' +
      '****Single-line:** 빠르고 정확한 도움을 제공하여 작업 완료를 용이하게 하고, 간단하고 반복적인 작업에 대한 키 입력 부담을 줄이는 것을 목적으로 한다.\n' +
      '**멀티라인:** 목표는 사용자가 API, 모범 사례 및 구현 세부 사항을 발견하는 데 도움이 되는 깊이 있는 정보에 입각한 지능형 지원을 제공하는 것입니다.\n' +
      '\n' +
      '우리는 그림 1의 단일 라인 완료, 그림 2의 다중 라인 완료의 어려움, 그림 3의 다중 라인 전략의 예를 제공한다. 그림에 대한 캡션은 독자가 예를 볼 수 있도록 광범위하다.\n' +
      '\n' +
      '### "jarring effect"의 정의\n' +
      '\n' +
      'CodeCompose는 사용자 유형으로 코드를 제안합니다. 이는 사용자가 기본 저작 워크플로우에 참여하는 동안 제안이 자주 나타나는 것을 의미합니다. 우리의 가장 엄격한 설계 원칙 중 하나는 제안이 침해적이지 않아야 하고 사용자 흐름에 원활하게 통합되어야 한다는 것이다. 사용자 피드백을 기반으로 사용자를 크게 방해하여 불쾌한 경험을 초래하는 제안을 식별했다. 이것의 두 가지 주요 인스턴스는 (1) 도 1에 도시된 바와 같이 사용자가 현재 읽고 있거나 타이핑하고 있는 기존 코드를 위, 아래 또는 오른쪽으로 시프트하는 제안들 (2) 도 2에 도시된 바와 같이 커서의 기존 범위와 겹치는 서식이 불량한 제안들과 같은 코드의 구조와 정렬되지 않는 제안들이다.\n' +
      '\n' +
      '"Jarring Effect"를 다루기 위한### 접근법\n' +
      '\n' +
      '_single-line_ 제안에 대한 "jarring effect"를 어드레싱하는 것은 비교적 복잡하지 않다. 기존 코드의 변위를 방지하기 위해 우리는 단순히 ], ]와 같은 특정 예외를 제외하고 커서의 오른쪽에 코드가 있는 경우 제안을 표시하는 것을 삼간다. 제안이 나타날 때 커서의 오른쪽에 어떠한 문자도 존재하지 않기 때문에, 어떠한 사용자 코드도 오른쪽으로 시프트될 수 없다. 또한, 선이 끝날 때까지만 제안하므로 기존의 커서 범위와 겹치는 포맷되지 않은 코드를 도입할 위험을 제거한다. 그러나, 멀티라인 제안의 경우, 커서의 아래에 존재하는 코드가 계속해서 위아래로 밀리고 있기 때문에, "jarring 효과"가 발생할 가능성이 더 크다.\n' +
      '\n' +
      '다중 라인 제안에 대한 흔들림 효과를 피하기 위해 다음 규칙을 준수합니다.\n' +
      '\n' +
      '* 다선 제안은 커서가 커서를 소유하는 범위의 끝에 위치할 때만 트리거된다.\n' +
      '* 멀티라인 제안들은 현재 범위가 끝날 때까지 보여져야 한다.\n' +
      '\n' +
      '사용자가 코드를 작성할 때, 그들의 흐름과 사고방식은 가장 내적인 범위에 있다. 따라서, 규칙 (1)을 만족시키는 것은 우리가 사용자에게 멀티 라인을 제안할 때, 아래로 밀리는 아래의 라인들이 외부 캡슐화 범위에 있음으로써, 사용자 흐름을 방해하지 않고, 자링 효과를 유발하지 않는다는 것을 보장한다. 더 나아가, 만족 규칙 (2)는 제안 구조가 중첩 없이 현재 스코프의 종료까지 완료되는 것을 보장한다.\n' +
      '\n' +
      '우리는 구체적으로 다음과 같은 경우에 다중 라인을 트리거한다:\n' +
      '\n' +
      '1. 커서는 그것을 포함하는 가장 내부 스코프의 끝에 위치된다.\n' +
      '2. 커서는 새로운 범위를 생성하는 새로운 기호를 정의하는 선의 끝에 있다.\n' +
      '3. 커서는 노트북 셀(벤투(Bento, 2018) 노트북 사용 케이스용)의 끝에 있다.\n' +
      '4. 사용자는 단축키를 이용하여 명시적으로 요청하였다.\n' +
      '\n' +
      '### 전략의 기술적 구현\n' +
      '\n' +
      '커서 위치에 따라 특정 경우에만 다중선을 트리거하기 위한 요구 사항은 코드구성 시스템에 의미적 컨텍스트 이해의 통합을 필요로 했다. 기존의 CodeCompose 시스템은 서버가 모델을 실행하는 추론 계층이고 클라이언트가 코드 제안을 표면화하는 편집기인 전형적인 클라이언트-서버 아키텍처(도 4에 도시됨)를 채용한다. 여러 편집기 통합에 걸쳐 재사용되는 LSP(Language Server Protocol) 컨포멀 언어 서버에서 클라이언트측 로직의 대부분을 인코딩한다. 클라이언트와 서버 간의 요청을 중재하기 위해 러스트에서 다양한 에디터 통합에 걸쳐 재사용할 수 있는 언어 서버를 구현하였다. 대부분의 언어 서버는 광범위한 전통적인 IDE 기능(자동 완성, 점프-투-정의 등)을 지원하도록 설계되지만, CodeCompose 언어 서버는 "textDocument/inlineCompletions"라는 하나의 의미 있는 요청 유형만을 지원한다.\n' +
      '\n' +
      '도 1. 단일-라인 "jarring" 효과 예: "def" 키워드와 "quicksort" 기능 사이에 위치된 사용자 커서가 나타나고, 인라인 제안은 기존의 사용자 코드를 우측으로 이동시킨다.\n' +
      '\n' +
      '도 2. 다중-라인 “jarring” 효과를 보여주는 예: 사용자 커서는 기능 이름과 문 “test1 = 1”을 포함하는 다음 라인 사이에 있었다. 제안이 발생하면 기존 라인은 개발자의 흐름을 방해하고 제안된 "퀵정렬" 기능을 검토하도록 강제하는 동시에 기존 코드의 정확한 위치를 결정한다.\n' +
      '\n' +
      '단일 라인에 대한 흔들림 효과를 피하는 것은 간단한 조건문이 필요했기 때문에 기술적인 관점에서 사소한 것이었다. 한편, 멀티 라인의 경우, 전술한 전략은 훨씬 더 복잡하고 프로그래밍 언어에 대한 상세한 의미적 맥락 이해가 필요하다.\n' +
      '\n' +
      '_Request 워크플로우 - Pre-processing_: 완료 요청이 클라이언트에서 언어 서버로 전송되고, CodeCompose 언어 서버는 파일의 현재 상태를 파싱하여 커서 위치를 파악한다. 커서의 위치가 위에서 설명한 경우 중 하나와 일치하면 이 요청은 다중 라인 요청으로 표시됩니다. 그런 다음 요청이 로컬 캐시에서 검증되며, 캐시 미스인 경우 다중 라인 요청으로 플래그된 CodeCompose 모델로 전송된다(도 3에 도시된 예).\n' +
      '\n' +
      '_Request 워크플로우 - Post-processing_: 모델 LLM은 제안들을 생성하고 응답을 언어 서버에 다시 전송한다. 모델 응답은 구조가 얼마나 잘 구성될지에 대한 엄격한 보장이 없습니다. 현재 범위에서 코드와 중복을 포함할 수 있습니다. 따라서 언어 서버에서 응답은 그림 5와 같이 현재 범위와 겹치는 경우 응답을 잘라내는 후처리 단계를 추가로 거치게 된다.\n' +
      '\n' +
      '마지막으로, 구현과 함께 엔드 투 엔드 자링 효과 또는 잘못된 절단이 없음을 검증하기 위해 광범위한 단위 테스트 제품군(473 테스트)을 구축했다.\n' +
      '\n' +
      '요약하면: (1) 멀티라인 제안들은 커서가 스코프의 끝에 있을 때만 트리거된다 (2) 제안들은 현재 블록의 끝에 있을 때까지 보여진다 (3) 제안이 수락된 후, 커서는 제안된 블록의 끝으로 이동될 필요가 있다.\n' +
      '\n' +
      '##4. 어드레싱 챌린지 2\n' +
      '\n' +
      '사용자 경험__응답 사용자 사용자 경험___응답 사용자 사용자 사용자 경험____응답 사용자 사용자 사용자 사용자 사용자 사용자 경험_____응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험_____ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험______ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험______ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험______ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 경험______ 응답 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자 사용자\n' +
      '\n' +
      '코드콤포즈의 인라인 제안들은 사용자 타입들에 따라 나타나고, 각각의 제안들은 파일의 주어진 상태와 정렬되고 (편집기의 사용자 인터페이스에서 해제됨) 사용자가 추가 키 스트로크를 입력하거나 커서를 이동하자마자 무효화된다. 이는 대기 시간이 사용자에게 표시되는 제안의 비율인 "표시 속도"를 결정하는 핵심 요소임을 의미합니다.\n' +
      '\n' +
      '단일 라인의 경우 뉴라인 또는 25개의 최대 토큰에서 중단하라는 제안의 생성을 제한한다. 평균 레이턴시가 낮기 때문에 디스플레이 속도는 주요 관심사가 아니다. 멀티라인 세대는 훨씬 더 길며(p50 325 chars, p90 450 chars), 최대 토큰은 120으로 설정된다. 이것은 큰 제안들에 대해 2초 이상 걸릴 수 있고; 따라서 멀티라인에 대한 레이턴시를 감소시키는 것은 디스플레이 레이트를 상당히 증가시킬 가능성이 더 크다. 이 섹션에서는 긴 다중 라인 세대를 생성하는 대기 시간을 줄이고 표시 속도를 높이는 데 중점을 두고 구축된 여러 접근법과 프로젝트에 대해 설명한다. 코드컴포즈 시스템의 모든 주요 구성 요소, 즉 클라이언트 측 편집기 확장, 언어 서버 및 모델을 호스팅하는 서비스에서 개선 작업을 수행했습니다.\n' +
      '\n' +
      '### 편집자 클라이언트 확장에서의 개선(즉, VSCode/벤투[1] 노트북)\n' +
      '\n' +
      '초기 테스트 동안 코드콤포즈의 다중 라인 제안들은 사용자가 타이핑함에 따라 자동으로 생성되었다. 하지만, 사용자의 것으로부터\n' +
      '\n' +
      '도 3. 전처리 단계를 나타내는 예: 어떤 유형의 제안이 표시되어야 하는 커서 위치에 기초하여 결정하는 것.\n' +
      '\n' +
      '관점, CodeCompose 제안이 여전히 처리되고 있으며 순간적으로 나타날지 또는 CodeCompose가 제안을 표시하지 않기로 결정했는지 여부를 알 수 있는 결정론적 방법은 없었다. 이러한 예측 불가능성은 사용자에게 좌절감을 유발하고 시스템을 신뢰할 수 없는 것처럼 보이게 했다.\n' +
      '\n' +
      '이를 해결하기 위해 그림 6에서 볼 수 있듯이 여전히 응답해야 하는 활성 완료가 있는 한 사용자 커서 옆에 팝업되는 인라인 스피너 표시기를 도입했다. 언어 서버의 전처리(3에서 설명됨)가 현재 요청이 다중 라인이어야 한다고 결정하자마자, 그것은 "CodeCompose/fetchingMultline" 통지를 에디터 클라이언트에 전송하고, 그 후 지시자를 렌더링한다. 요청이 응답되거나 취소되면 편집자는 지시자를 무시합니다.\n' +
      '\n' +
      '사용자의 정신 모델은 제안이 나타날 것으로 예상되는지 여부를 아는 데 뿌리를 두고 있다. 인라인 표시기는 사용자가 다중 라인 제안이 처리되고 있는지 여부를 알 수 있게 하고, 따라서 다음 문자를 입력할 것인지 아니면 다가오는 제안을 보기 위해 조금 더 기다릴 것인지에 대한 결정을 내릴 수 있게 한다. 이러한 피드백은 특히 더 긴 멀티라인 제안들을 위해 사용자들을 조금 더 기다리게 함으로써 전체 디스플레이 레이트를 향상시킨다. 이는 코드컴포즈 시스템에 대한 신뢰를 구축하는 데 도움이 되는 사용자에게 투명하고 예측 가능한 경험을 초래한다.\n' +
      '\n' +
      '다중 라인 제안을 생성하는 데 상당히 오래 걸리기 때문에 사용자가 다중 라인 제안이 생성되고 있음을 알 수 있도록 회전 UI 표시기를 추가했다. 이는 단일 라인 제안보다 다중 라인 제안의 인지된 대기 시간을 감소시키고 사용량을 증가시켰다.\n' +
      '\n' +
      '### 모델 호스팅 서비스의 최적화\n' +
      '\n' +
      '우리는 대기 시간 단축을 주요 목표로 모델 호스팅 서비스에 대한 수많은 개선을 구현했다. 우리의 가설은 지연 감소가 특히 생성 시간이 상당히 긴 다중 라인 제안에 대해 모든 정량적 결과 메트릭을 증가시킬 것이라는 것이었다. 더 빨리 이용 가능하다는 제안은 더 많은 제안들이 사용자들에게 보여졌다는 것을 의미할 것이고, 그 제안들이 보여지지 않게 할 또 다른 액션(예를 들어, 다음 캐릭터를 타이핑하는 것)을 취했을 것이다.\n' +
      '\n' +
      '그림 4. CodeCompose의 시스템 아키텍처: 제안들을 표면화하는 클라이언트 에디터, CodeCompose 모델 서비스 호스트와 요청을 중재하는 언어 서버. 요청에서 "멀티라인" 플래그는 모델 서비스로 전달된다.\n' +
      '\n' +
      '도 5. 후처리 단계를 보여주는 예: 커서는 "foo" 기능의 범위에 있다. 비록, 모델이 "foo" 및 "foo2" 기능 둘 다의 다중 라인 제안을 리턴하지만, 후처리는 적색 박스 내의 코드를 제거할 것이고, 사용자에게 범위 내 "foo" 기능에 대한 제안만을 디스플레이할 것이다.\n' +
      '\n' +
      '도 6. 커서의 왼쪽에 보여지는 스피너를 갖는 인라인 표시자(주황색 밑줄로 표시됨)를 사용자에게 경고하는 코드콤포즈는 곧 AI 제안을 보여줄 수 있다\n' +
      '\n' +
      '6월 중순부터 9월까지 코드콤포스에 대한 일련의 A/B 실험(Krishnan et al., 2017)을 실행했는데, 코드콤포스는 수천 명의 메타 엔지니어 중 10명으로 롤아웃되어 지연 시간을 점진적으로 개선한다: 우리는 초기에 연기 테스트로 모집단의 10%로 롤아웃한 후 1주일 동안 50% 롤아웃에서 메트릭을 비교하여 모든 결과 메트릭에 대한 지연 영향을 검증했다. 아래에서는 실행한 각 대기 시간 실험을 강조 표시한 다음 섹션 5의 순 메트릭 이득을 요약합니다.\n' +
      '\n' +
      '**Flash Attention.** 플래시 어텐션(Krishnan et al., 2017)을 6.7B InCoder 기반 FIM-trained model 상에서 multi-line 제안으로 구현하였을 때, 첫 번째 토큰 레이턴시의 중간값 2.53x 감소와 마지막 토큰의 레이턴시의 중간값 1.15x 감소를 보았다. 플래시 어텐션은 주로 모델의 어텐션 스택의 개선이므로 첫 번째 토큰 레이턴시의 더 큰 개선이 예상되었다. 우리의 실험에서 우리는 표시된 제안 수의 13% 증가, 수락률의 8% 증가, 수락된 제안의 평균 길이의 3% 증가를 발견했다. 전반적으로 플래시 어텐션이 다중 라인보다 단일 라인 제안 대기 시간을 훨씬 더 개선했으며 단일 라인 제안이 모델이 생성하는 대부분의 제안이기 때문에 중간 대기 시간이 74% 감소했다.\n' +
      '\n' +
      '**CUDA 그래프와 융합 커널.** CUDA 그래프와 융합 커널(Krishnan et al., 2017)을 함께 사용하여 6.7B InCoder 기반 FIM 훈련 모델에서 중간 생성 대기 시간이 29% 감소하고 90번째 백분위수에서 대기 시간이 40% 감소하는 것을 관찰했다. 지연 감소는 표시된 제안의 절대 수를 26% 증가시키고 수락된 제안의 총 수를 17% 증가시켰다. 그러나 우리는 또한 1%의 수용률 하락을 관찰했다. 이 실험을 통해 합격률이 잠복기와 엄격하게 상관 관계가 없다는 것을 알게 되었다. 우리는 이 실험 동안 지연 시간의 개선이 점점 더 낮은 수용률의 환경에서 제안이 나타났다고 가정한다. 예를 들어, 사용자가 제안을 거부한 다음 한 문자만 더 타이핑하면, 새로 생성된 제안은 낮은 대기 시간으로 즉시 표시되더라도 수락되지 않을 것이다.\n' +
      '\n' +
      '**Queue Priority.** 더 긴 멀티라인 제안이 GPU 용량 활용에 미치는 영향을 연구했습니다. 우리는 더 긴 세대가 용량 부하에 큰 영향을 미친다는 것을 발견했다. 또한, 더 긴 다중 회선 제안에 대한 요청은 단일 회선 요청의 거의 2배 속도로 타임아웃 응답을 받고 있었다. 우리는 타임아웃 비율 간의 큰 차이가 우리가 사용하는 트리거링 전략에 의해 생성되는 이유를 의심한다(섹션 3에 설명된 대로). 큐 경쟁을 완화하기 위해, 우리는 더 긴 다중 회선 요청을 이용하기 위해 QoS를 구현했다. 우리는 다중 회선 성공률을 높이기 위해 짧은 단일 회선 요청에 비해 대기열 재태 시간을 증가시켰다. 이러한 노력은 다중 라인 타임아웃 응답의 크기를 줄이는 데 성공했다. 표시된 다중 라인 제안의 수를 늘리는 데 성공했으며 저장된 키 입력이 1% 절대 증가하는 것을 관찰했다.\n' +
      '\n' +
      '**스트리밍 및 조기 취소.** 범위가 끝날 때 생성된 제안을 잘라내기 위한 작업을 구축(섹션 3.3 참조)한 결과 생성된 모든 문자의 54%가 표시되기 전에 잘려나가는 것으로 나타났다. 또한, 모델에 의해 생성된 모든 제안의 47%가 표시되지 않았다. GPU 용량으로 낭비되는 이러한 노력을 줄이기 위해 클라이언트가 스트림을 닫을 때 조기 취소를 허용하는 스트리밍 응답 메커니즘을 도입했다. 스트리밍을 통해 클라이언트는 생성된 제안 중 하나가 더 이상 필요하지 않거나 모델이 잘릴 문자를 생성했다는 것을 모델 서비스로 다시 통신할 수 있다. 우리는 취소와 함께 스트리밍을 구현한 결과 전체 모델 서비스 요청 왕복 지연 시간이 45% 개선되는 것을 관찰했다.\n' +
      '\n' +
      '**Batching.** 우리는 응답을 1.5배 더 빨리 제공하기 위해 2방향 텐서 병렬성을 사용했다. 이것은 요청을 서빙하기 위해 두 개의 GPU를 사용하지만, 2배만큼 대기 시간을 개선하지 않기 때문에, 동일한 워크로드를 처리하기 위해 더 많은 용량을 효과적으로 요구한다. 그러나 우리는 이것이 연속 배칭을 사용하여 보상될 수 있음을 발견하여 훨씬 더 빠른 응답을 제공하는 동시에 여러 요청의 배치 효과로 인해 향상된 유효 용량을 얻을 수 있음을 발견했다.\n' +
      '\n' +
      '대기 시간을 개선하면 복합 효과가 있습니다. 대기 시간 분포를 줄이면 더 많은 요청을 처리할 수 있는 기계의 유효 용량이 증가합니다. 예를 들어, 위의 최적화는 GPU 수가 2.5배 감소하면서 동일한 요청을 제공할 수 있다. 주요 이유는 취소된 요청에 대한 계산 낭비가 적고 요청을 일괄 처리할 수 있기 때문이다. 용량 활용률을 줄이면 대기 시간 및 왕복 대기 시간 분포가 더욱 줄어듭니다.\n' +
      '\n' +
      '텐서 병렬과 연속 배치와 함께 스트리밍을 결합하여 중간 단일 라인 제안을 440ms에서 280ms(1.5배 더 빠른/35% 지연 감소)로, 중간 다중 라인 제안을 2000ms에서 750ms(2.5배 더 빠른/60% 지연 감소)로 가속화했다. 이는 결국 사용자가 수용한 캐릭터의 상대적 16% 향상으로 이어졌다. 이는 대기 시간이 코드 완성 도구의 효율성에 상당한 영향을 미친다는 것을 확인시켜준다.\n' +
      '\n' +
      '모델 호스팅 서비스를 최적화하기 위해 5가지 기술에 투자했으며, 이는 다중 회선 제안의 중간 대기 시간을 750ms까지 줄였다. 이는 5절의 A/B 실험을 통해 검증된 바와 같이 사용자에게 보여지는 제안의 #과 사용자가 저장한 전체 키 입력을 증가시켰으며, 반응형 UX를 갖는 것이 다중 라인 제안의 채택에 중요했다.\n' +
      '\n' +
      '## 5. 어드레싱 챌린지 3\n' +
      '\n' +
      '측정값__제작 릴리스 및 유효성 측정값_\n' +
      '\n' +
      '마지막 과제는 이전 섹션에서 열거된 실험 기능의 효과를 모니터링하는 것이었다. 각 기능이 사용자 경험을 개선하는지 여부를 평가하기 위해 실시간으로 호스트 메트릭을 추적하고 그에 따라 기능을 조정했다. 이러한 메트릭에는 수용률, 표시 속도, 대기 시간, 저장된 % 키 입력 및 사용자당 허용되는 문자 #이 포함되었다. 사용자에 대한 각 기능의 순 이점을 결정하기 위해 단일 라인 대 다중 라인 제안에 의해 메트릭이 분해되었다. 각 기능 릴리스를 제어하고 테스트하기 위해 50/50 분할로 A/B 실험을 실행했다.\n' +
      '\n' +
      '다선 제안의 해제를 위한### 실험\n' +
      '\n' +
      '첫째, 다중 라인 트리거 포인트 각각을 롤아웃할 때(도 3에서 설명됨), 사용자 경험에 대한 부정적인 영향에 대해 수용률과 처리량 모두를 면밀히 모니터링했다:1. 다중 라인 제안은 단일 라인 제안을 읽는 것보다 다중 라인을 검토해야 하기 때문에 사용자에게 더 많은 정신적 노력이 필요하다.\n' +
      '2. 다중 라인 제안들은 대체 효과를 야기한다 - 트리거 포인트들 중 일부(예를 들어, 새로운 기능 블록에서 새로운 라인을 타격할 때)는 단일 라인과 중첩된다. 멀티-라인 제안들을 생성하기 위한 더 긴 레이턴시로 인해, 사용자들은 결국 이러한 트리거 포인트들을 지나 타이핑하게 되어, 코드콤포즈가 타이핑된 키스트로크들 상에서 사용자들을 저장하기 위한 놓친 디스플레이 기회를 야기할 수 있다(반면, 그것의 더 낮은 레이턴시를 고려할 때 단일-라인 제안이 디스플레이되었을 것이다).\n' +
      '3. 사용자들은 때때로 그들의 워크플로들에 따라 하나 또는 두 개의 더 긴 다중 라인 제안들 대신에 연속적인 단일 라인 제안들을 보는 것을 선호할 수 있다\n' +
      '\n' +
      '그림 7에서 볼 수 있듯이 6월 중순에 처음에 다중 라인 제안을 롤아웃할 때 사용자당 표시된 제안의 수가 크게 감소했는데, 이는 생성 시간이 길어 사용자가 트리거 지점을 지나 타이핑하게 했기 때문이다.\n' +
      '\n' +
      '그러나 (1) 중간 다중 라인 대기 시간을 2000ms에서 750ms로 줄이는 투자로 인해 (둘 다 섹션 4에 설명된) 인라인 표시기를 보여주는 (2) 이 표시 메트릭은 8월 말까지 점차적으로 원래 수준에 가깝게 복원되었다. 이러한 레이턴시 투자는 단일 라인과 다중 라인 제안 사이의 인지된 레이턴시 갭을 감소시켰고, 이는 사용자가 제안 UL의 증가된 응답성과 함께 다중 라인 제안을 점점 더 가치 있게 발견함에 따라 처리량의 지속적인 증가에 기여했다.\n' +
      '\n' +
      '생산 모니터링을 통해 두 제안 유형 간에 수용률도 29%로 유사하게 유지되어 더 긴 제안(정확하게 예측하기 어려운)에도 불구하고 다중 라인 제안은 여전히 단일 라인과 유사한 비율로 선호된다는 것을 강화했다. 따라서 주어진 표시 기회에 더 많은 코드 라인이 수락되었기 때문에 전체 처리량이 증가한다.\n' +
      '\n' +
      '또한, 항아리 효과를 줄이기 위해 다중 라인 제안을 덜 자주 트리거했기 때문에 다중 라인 제안은 표시된 전체 제안 부피의 약 16%만 차지했다. 그러나 그림 8과 같이 다중 라인 제안은 사용자가 수락한 전체 문자의 42%를 차지했다. 이러한 처리량 메트릭은 사용자 인식 대기 시간을 줄이는 데 대한 투자의 성공을 보여주었으며, 이는 차례로 단일 라인 제안에 비해 다중 라인 제안의 사용을 증가시켰다.\n' +
      '\n' +
      '마지막으로 온라인 모니터링 메트릭은 시간이 지남에 따라 제품에 대한 추가 개선을 위한 다중 라인 제안이 올바른 표면임을 보여준다. 표 1에서 볼 수 있듯이 CodeLlama-7B 모델을 출시할 때 단일 라인 처리량의 +25% 상대 개선에 비해 다중 라인 처리량의 +40% 상대 개선으로 다중 라인에 미치는 영향이 훨씬 더 크다는 것을 관찰했다. 이것은 예를 들어, 생성을 위한 최대 토큰 길이를 증가시킴으로써, 또는 더 많은 위치들에서 다중-라인 제안들을 트리거함으로써, 더 길고 더 긴 제안들을 생성하기 위한 추가 투자들의 문을 개방한다.\n' +
      '\n' +
      '그림 8: 제안 유형별로 세분화된 총 문자 수용. 더 높은 지연 시간 및 더 낮은 주파수(디스플레이된 제안의 총 볼륨의 16%)를 갖는 다중 라인 제안 트리거. 그러나 다중 라인 제안은 사용자가 수락한 전체 문자의 42%를 차지한다.\n' +
      '\n' +
      '그림 7: p50 및 p75에서 하루 사용자당 표시된 제안의 #. 이 표시 메트릭은 6월 중순에 더 높은 대기 시간 다중 라인 제안이 롤아웃됨에 따라 감소했지만 인지 대기 시간에 대한 투자로 인해 8월 말까지 복구되었다.\n' +
      '\n' +
      '### 사용자 피드백 및 옵트아웃률\n' +
      '\n' +
      '이전 섹션에서 관찰된 메트릭 개선을 삼각측량하기 위해 정성적 사용자 피드백을 모니터링했다. CodeCompose가 "jarring" 효과를 다루기 전에, 그리고 새로운 CodeLlama-7B가 배치되기 전에, 몇몇 사용자들은 "jarring 효과" 및 멀티라인 제안들의 품질에 대해 불평했다:\n' +
      '\n' +
      '* _"[Negative] 최근에, 나는 Python 다중 라인 제안들을 산만하게 찾고 있다. 이 DevX는 단일 라인 완성들과는 상당히 다르게 느껴진다: 그것은 내 코드를 주변으로 이동시켜, 내가 무슨 일이 일어났는지 파악하기 위해 내가 쓰고 있는 라인으로부터 시선을 이동하게 한다. 때때로 코드는 유용하지만, 이는 단일 라인 완성들에 비해 대체로 유용하지 않았다(나는 이것을 제안 수락률 데이터에서 보는 것을 상상한다). 우리는 어떻게 이 DevX를 덜 방해하게 할 수 있는지, 그리고 우리는 제안 품질을 개선하기 위해 작업한다."__\n' +
      '\n' +
      'CodeCompose의 다중 회선 알고리즘을 개발한 후, 피드백은 훨씬 더 긍정적이었다:\n' +
      '\n' +
      '* _"[긍정] 제안의 스크린샷을 찍을 정도로 놀라움과 즐거움의 순간이 너무 많았다. 코드작성은 코딩의 지루한/페인팅한 부분을 너무 많이 자동화하여 매우 재미있고 빠르게 만들기 시작했다. <몇 년 전의 인프라 기능 변화> 이후 이렇게 놀라운 생산성 도약을 느껴본 적이 없다._\n' +
      '* _"[Positive] 저는 <언어 - 다중 줄 문자열이 있는 줄 몰랐습니다; 이것은 제가 하나를 사용하는 것이 더 나은 상황에서 나타났고 발견에 감사하는 "__\n' +
      '* _"[Positive] CodeCompose에 관하여: 내가 인간으로서 그렇게 예측 가능한 사람이 되었는가! 내 의도는 이전에 정의한 사전을 기반으로 SQL case-when statement를 생성하는 파이썬 함수를 쓰는 것이었다. 함수의 이름을 입력하고 5-line return statement를 자동 생성했다. 정확하게 추측했다. 나는 SQL case-when statement를 만들고 싶었고, 내 머릿속에서 생각하는 것처럼 함수를 썼다! 나는 항상 개인이 코드를 쓰는 방식이 그 개인에게 유일하다고 생각했다! 나도 인간으로서 그렇게 예측 가능한 사람이 되었는가! 더 이상!\n' +
      '* _"[Positive] 성가신 상용구를 처리하고, 상태\\(\\sim\\) 쿼리\\(\\sim\\) 응답을 통해 5개의 변수를 전파한다. 코드콤포즈는 이것들의 작업을 나의 통상적인 카피+붙여넣기+선택+변경 동작[...]보다 더 빠르게 만든다. 일반 함수를 쓰고 코드를 교체하는 것은 모두 50%+ 수락된 제안들"_\n' +
      '* _"[긍정] CodeCompose는 이와 같은 일반적인 기능을 쓸 때 매우 놀랍다. 물론, 이것은 기능의 다른 부분을 제대로 얻지 못했지만 여전히 키 입력을 90% 줄이는 데 도움이 되었기 때문에 완벽하지 않다."_\n' +
      '* _"[혼합] CodeCompose 제안의 첫 번째 행이 상당히 좋은 여러 경우를 알아챘지만, 그 제안은 약간 너무 야심 차게 되어 그 이상의 여러 행을 코드와 함께 하게 되는데, 이는 주관적으로 내가 원하는 것이 아니며 객관적으로 내가 지금까지 타이핑한 것으로 표현한 의도와는 관련이 없다."_\n' +
      '* _"[부정] 다중 회선 제안은 거의 유용하지 않으며, 실수로 수락하면 문제를 유발합니다."_\n' +
      '\n' +
      '사용자 피드백은 다중 라인 제안과 같은 기능을 실행할 때 필요한 복잡한 균형을 강조합니다. 이 균형은 표시 속도와 각 제안의 라인 수에 나타난 리콜과 제안 자체의 품질 사이에 있다. 본 논문에서는 이러한 문제점을 완화하고 모델의 품질을 향상시킴으로써 멀티라인 제안의 품질을 향상시킴에 따라 사용자 피드백의 개선 효과를 관찰하였다. 정성적 피드백에 대한 완전한 주제론이나 근거 이론 분석을 향후 작업으로 남겨두지만, 위의 증명에서 보듯이 초기 사용자 피드백은 압도적으로 긍정적이었다.\n' +
      '\n' +
      '또한 멀티라인 기능을 비활성화한 엔지니어는 거의 없습니다. 코드콤포즈의 전체 옵트아웃률은 모든 사용자의 \\(<0.8\\%\\)에서 시간이 지남에 따라 일정하게 유지되었다. 우리는 사용자가 단일 라인 제안을 켜는 동안 다중 라인 제안을 구체적으로 전환할 수 있도록 허용했다. 여기서 다중 회선 옵트아웃 비율은 전체 사용자의 \\(<0.1\\%\\)에서 훨씬 낮아 다중 회선 제안에 대한 광범위한 채택과 호감도를 나타낸다.\n' +
      '\n' +
      '다중 라인 제안의 롤아웃 동안, 우리는 다중 라인 제안 대 다중 라인 제안의 순 이점을 평가하기 위해 수락률, 디스플레이 속도, 대기 시간 및 처리량과 같은 메트릭을 모니터링했다. 단일 라인 제안. 이러한 메트릭은 다중 라인 제안이 하루 사용자당 수락된 총 문자의 42%를 차지하기 때문에 다중 라인 제안에 대한 투자가 처리량을 불균형적으로 증가시켰음을 보여주었으며(표시된 제안의 16%만을 차지함에도 불구하고), 키 입력 비율의 상당한 순 증가를 9%에서 17%로 거의 두 배로 감소시켰다(표 1에 나타난 바와 같이). 1% 미만의 엔지니어가 다중 회선 제안을 선택하지 않고 비활성화했습니다.\n' +
      '\n' +
      '##6. 유효성에 대한 위협\n' +
      '\n' +
      '### Generalizability\n' +
      '\n' +
      '이 연구는 메타에서 수행된다. 이것은 단일 회사이지만 오픈 소스 프로젝트에서 일반적으로 연구된 것보다 여러 배 더 큰 코드베이스를 포함한다. 또한 소셜 네트워크에서 데이터베이스 및 연속 통합 시스템과 같은 인프라 프로젝트에 이르기까지 광범위한 소프트웨어 시스템을 포괄하는 코드를 포함합니다. VR 하드웨어에서 직접 실행되는 소프트웨어도 있습니다. 10대 수천 명의 엔지니어로 코드콤포즈를 출시할 수 있습니다. 우리의 결과는 모델을 훈련할 큰 코드베이스가 없는 소규모 회사 및 프로젝트에 일반화되지 않을 수 있다.\n' +
      '\n' +
      '###구성 및 내적 타당도\n' +
      '\n' +
      '섹션 2.3에서 다중 라인 코드콤포즈가 효과적인지 확인하기 위해 추적하는 메트릭을 설명한다. AI 지원의 대규모 배포가 거의 없었기 때문에 메타에서 기존 인프라를 사용하여 표시 속도, 대기 시간, % 키 입력 저장, 사용자당 허용되는 문자 # 및 옵트아웃 비율을 추적했다. 만 명의 엔지니어에 걸친 A/B 테스트에서 결과는 각 메트릭에 대해 양성이었고 전체 회사에 다중 라인을 출시할 수 있을 만큼 설득력이 있었다. 이러한 메트릭을 계속 모니터링하기 위해 대시보드를 만들었습니다. 향후 작업에서 우리는 다른 연구자와 회사가 유용하다고 발견한 측정 기준을 추적하고자 한다.\n' +
      '\n' +
      '##7. 토론 및 관련 작업\n' +
      '\n' +
      '코드 완성에 대한 소프트웨어 공학 연구 작업의 큰 본체가 있는 반면(Han et al., 2017; Wang et al., 2017; Wang et al., 2017; Wang et al., 2018; Wang et al., 2018), 대규모 산업 환경에서 이들의 배치가 제한적이었다(Beng et al., 2015; Chen et al., 2016; Chen et al., 2017; Chen et al., 2018). 생성 AI의 출현으로 코드 보조 영역의 발전은 이제 몇 달이 아니라 몇 주이다. 이러한 결과 중 일부는 단일 라인과 다중 라인 제안 간의 상충 관계를 평가하는 제한된 논의와 함께 전통적인 논문이 아닌 블로그 게시물로 배포된다.\n' +
      '\n' +
      '따라서 AI 코드 어시스턴트에는 다중 라인 지원이 일반적이지만 우리가 아는 한 가장 먼저 기여도를 설명한다.\n' +
      '\n' +
      '1. AI 지원 제안을 위한 스코프 기반 멀티라인 알고리즘 사용\n' +
      '2. 기업 제품에서 AI 지원 제안의 응답성을 향상시키기 위한 일반적인 LLM 최적화 적용\n' +
      '3. A/B 산업 규모 롤아웃을 전개하여 다중 라인 대 단일 라인 제안의 효과를 정량화\n' +
      '\n' +
      '### 범위 기반 다중선 알고리즘\n' +
      '\n' +
      '많은 도구가 다중 라인 제안을 제공하지만 "재링" 효과를 피하거나 표시된 코드 양을 신중하게 제한하기 위해 사용하는 알고리즘에 대한 논의는 찾지 못했다. 예를 들어, Amazon의 CodeWhisperer(Beng et al., 2015)는 멀티-라인 제안들을 생성하도록 구성될 수 있지만, 제안들은 현재 의미 범위를 넘어 무제한으로 실행되어 사용자에게 일정한 산만함을 야기하는 것으로 보인다. 그들은 또한 섹션 3에 설명된 자동 의미 기반 알고리즘을 통해 촉발되기보다는 문서 문자열과 같은 매우 특정한 맥락에서 우선적으로 촉발되는 것으로 판단된다.\n' +
      '\n' +
      '구글의 ML 코드 완성도(Chen et al., 2016)는 시멘틱 필터를 기반으로 다중 라인 제안을 자동으로 제한하지만, 이는 우리의 접근법에 비해 훨씬 더 제한적인 알고리즘을 초래한다. 그들은 드롭다운 메뉴에서 다음 토큰과 전체 라인 제안을 모두 보여주며 완료 길이는 현재 토큰에 따라 다르다. 저자들은 다중 라인 완성을 보여주지만, 몇 개의 추가 라인 또는 완성에 어떤 다른 제한이 적용되는지는 불분명하며 다중 라인 알고리즘은 설명되지 않는다.\n' +
      '\n' +
      '계약에서 CodeCompose의 다중 라인 알고리즘은 사용자 유형으로서 자동으로 트리거링되며, 트리거 포인트가 사용되는 신중한 상태를 유지하면서 생성된 제안을 사용자의 현재 범위로 선택적으로 제한한다. 다중 라인 제안은 정확하게 생성하기 더 어렵지만, 범위 기반 알고리즘은 사용자의 현재 사고 컨텍스트에 맞는 제안을 표시할 수 있으므로 추가 노이즈를 생성하지 않고 사고 열차를 지원할 수 있다.\n' +
      '\n' +
      '### Responsive UX\n' +
      '\n' +
      '제품의 반응성을 높이기 위한 대기 시간 감소와 관련하여, 우리가 기술하고 있는 많은 기술들은 소프트웨어 엔지니어링(예를 들어, 조기 취소/스트리밍)에서 표준적이거나 변압기 성능을 최적화하기 위한 공개된 기술들(예를 들어, Flash Attention(Han et al., 2017), xFormers(Chen et al., 2018))이다. 그러나 산업 환경에서 이들을 배치하는 것의 영향에 대한 발표된 연구는 거의 없다. Copilot, Codeium, CodeWhisperer(Beng et al., 2015; Chen et al., 2018)와 같은 다양한 외부 제품 릴리스가 사용자 경험의 품질을 향상시키기 위한 중요한 드라이버로서 레이턴시 감소를 언급하지만, 이들은 일련의 제품 메트릭에 걸쳐 레이턴시 영향에 대한 엄격한 평가를 제공하지 않는다.\n' +
      '\n' +
      '따라서 우리가 아는 한, 이러한 지연 감소를 유도하는 특정 알고리즘의 열거와 생산 환경에서 출시될 때 이들의 영향 측정에 처음으로 기여했다.\n' +
      '\n' +
      'Multi-Line과 Single-Line 제안의 효과성 평가\n' +
      '\n' +
      '섹션 5에 설명된 바와 같이, 일련의 신속한 단일 라인 제안이 사용자에 의해 더 잘 수신될 수 있기 때문에 다중 라인 제안이 제품 경험에 대한 순 개선인지 여부를 결정하는 것은 간단하지 않다. 우리가 아는 한, 우리는 단일 라인과 다중 라인 제안 사이의 균형을 보여주는 A/B 롤아웃의 업계 지표를 처음으로 보여준다. 섹션 5.1에서 알 수 있듯이 실험 메트릭은 지연 트레이드오프에도 불구하고 더 긴 다중 라인 제안이 일련의 더 짧은 단일 라인 제안보다 사용자에게 더 영향을 미친다는 가설에 대한 증거를 제공한다.\n' +
      '\n' +
      '** 정량적 비교.** 제품 간에 정량적 결과의 직접적인 비교는 불가능하지만(다른 컨텍스트, 사용자 및 도구를 감안할 때), 유사한 조치가 보고될 때 전체 추세를 비교할 수 있다. 구글에서 엔지니어(Chen et al., 2016)는 10k+ 구글 직원(8개 프로그래밍 언어에 걸쳐 3개월 이상)에게 하이브리드 시맨틱 ML 코드 완료를 배포했다. 그들은 대조군에 비해 단일 라인 ML 완료에 노출된 사용자에 대해 코딩 반복 시간(빌드와 테스트 사이의 시간)이 6% 감소하는 것을 관찰했다. 저자들은 코드콤포즈의 다중 라인 키스트로크 절감의 7%에 비해 다중 라인에서 0.6% 절약되는 비교적 낮은 키스트로크 절감량을 측정했다. 이 차이는 구글이 생성한 각 제안에서 더 낮은 표시 속도 또는 더 낮은 라인 수를 나타낸다. 저자들은 후처리 단계에서 의미적 필터링이 적용된다고 언급하는데, 이러한 유형의 필터링은 CodeCompose에서 적용되지 않으며 구글의 제품에서 더 낮은 디스플레이 비율을 설명할 수 있다.\n' +
      '\n' +
      '대조적으로, 메타에서, 시맨틱 필터 및 드롭다운 메뉴 제약을 사용하는 것이 아니라, CodeCompose 완성들은 파일에 직접 도시되고, 커서의 위치에 의존한다. 따라서 우리의 제안은 더 많은 커서 위치에서 자동으로 트리거되어 보고되는 디스플레이 속도와 전체 처리량을 높일 수 있다.\n' +
      '\n' +
      '아마존의 CodeWhisperer(Beng et al., 2015)는 IDE에 통합된 완전 기능 코드 완성 도구이다. 아마존의 분석에 따르면 언어 모델은 올바른 구문으로 코드를 생성하고 의도적으로 훈련되지 않은 프로그래밍 언어로 단위 테스트를 통과할 수 있다. 도구는 멀티-라인 제안들을 생성하도록 구성될 수 있지만, 이러한 제안들은 더 제한된 컨텍스트들에서 그리고 사용자에게 상당한 레이턴시를 갖는 트리거링으로 나타나, 멀티-라인이 얼마나 효과적인지 불분명하게 한다. 단일 라인 대 다중 라인 제안이 전체 제품에 미치는 정량적 메트릭 영향에 대해 아마존에서 세부 사항을 찾을 수 없었다.\n' +
      '\n' +
      '자동 코드 완성을 위한 실제 사용에서 GitHub의 Copilot(Chen et al., 2016)에 대한 몇 가지 실증적 평가가 있었다. Nguyen et al.(2017)은 33개의 LeetCode 질문을 사용하여 4개의 다른 프로그래밍 언어로 코파일럿에 대한 쿼리를 생성하였다. 그들은 코파일럿의 Java 제안이 가장 높은 정확성 점수(57%)를 갖는 반면 JavaScript는 가장 낮은 정확도 점수(27%)를 갖는다는 것을 발견했다. 전반적으로 코파일럿의 제안은 프로그래밍 언어 간에 눈에 띄는 차이 없이 복잡성이 낮았다. 그들은 또한 더 단순화될 수 있는 코드를 생성하고 정의되지 않은 도우미 방법에 의존하는 코드를 생성하는 것과 같은 몇 가지 잠재적인 코파일럿 단점을 관찰했다(Krishnan et al., 2017).\n' +
      '\n' +
      '**정성적 비교.** 코드 완성의 모든 산업 용도가 긍정적인 것은 아닙니다. 프로그래머가 코파일럿을 어떻게 사용하고 인지하는지 이해하기 위한 사용자 연구(Krishnan et al., 2017)는 코파일럿이 작업 완료 시간이나 성공률을 반드시 향상시키지는 않지만, 코파일럿이 종종 유용한 시작점을 제공하고 온라인 검색의 노력을 절약하기 때문에 대부분의 참가자가 일상적인 프로그래밍 작업에서 사용하는 것을 선호한다는 것을 발견했다. 그러나, 참가자들은 코파일럿에 의해 생성된 코드 스니펫을 이해, 편집 및 디버깅하는 데 어려움을 겪었고, 이는 그들의 과제 해결 효과를 상당히 방해했다(Krishnan et al., 2017).\n' +
      '\n' +
      '이러한 혼합 결과는 또한 Bird_et al._(Bird et al., 2017)에 의해 에코되었으며, 개발자는 코딩에서 가속도를 인식하지만 생성된 코드를 검토하는 데 훨씬 더 많은 시간을 보내야 한다는 것을 발견했다. 반면, 일부 다른 연구에서는 생성된 제안이 새로운 API를 발견하는 데 도움이 된다는 것을 발견했다(Bird et al., 2018).\n' +
      '\n' +
      'CodeCompose에 대한 우리의 이전 작업은 코딩을 가속화하고 개발자가 모노레포 전체에서 새로운 API를 발견할 수 있도록 하는 단일 라인 완성에 대해 압도적인 91.5%의 긍정적인 피드백을 발견했다(마찬가지로, 섹션 5.2에 설명된 사용자 피드백은 사용자가 다중 라인 제안이 롤아웃됨에 따라 경험에서 눈에 띄는 개선을 발견했음을 보여주며, 이는 상용구 코드의 더 긴 블록을 생성하고 발견에 도움이 되는 더 복잡한 제안을 생성하는 데 성공했음을 나타낸다. 따라서 우리의 작업은 긍정적인 사용자 경험을 유지하면서 다중 라인 제안을 생성하면서 더 넓은 커뮤니티가 이러한 방향으로 계속 투자할 수 있는 기반을 마련한다.\n' +
      '\n' +
      '##8. 결론 및 기여도\n' +
      '\n' +
      '본 논문에서는 우리가 해결한 과제와 관련하여 다음과 같은 기여를 한다.\n' +
      '\n' +
      '***Challenge 1. The Jarring Effect**: 본 발명자들은 다음과 같은 scope-based algorithm (1) Multi-line 제안들은 커서가 scope의 끝에 있을 때만 트리거된다 (2) 제안들은 현재 블록의 끝에 있을 때까지 보여진다 (3) 제안이 수락된 후, 커서는 제안된 블록의 끝으로 이동될 필요가 있다.\n' +
      '**챌린지 2. 응답 UX**: 다중 라인 제안들은 생성하는데 상당히 더 오래 걸리므로, 우리는 단일 라인 제안들에 비해 사용자 채택을 보장하기 위해 인지된 사용자 대기 시간을 줄여야 했다. 이것은 (i) 사용자가 생성됨에 따라 멀티라인 제안이 생성된다는 것을 인식하도록 (ii) 모델 호스팅 서비스(예를 들어, 플래시 어텐션, 영구 K-V 캐시)를 실행하는 것에 의해 수행되었다.\n' +
      '**챌린지 3. 생산 릴리스 효과**: 멀티라인 제안의 롤아웃 동안, 멀티라인 제안 대 멀티라인 제안의 순 이점을 평가하기 위해 수용률, 디스플레이 속도, 대기 시간 및 처리량과 같은 메트릭을 모니터링했다. 단일 라인 제안. 이러한 메트릭은 다중 라인 제안이 하루 사용자당 수락된 총 문자의 42%를 차지하기 때문에 다중 라인 제안에 대한 투자가 처리량을 불균형적으로 증가시켰으며(표시된 제안의 16%만을 차지함에도 불구하고), 키 입력 비율의 상당한 순 증가를 9%에서 17%로 거의 두 배로 감소시켰음을 입증했다. 1% 미만의 엔지니어가 다중 회선 제안을 선택하지 않고 비활성화했습니다.\n' +
      '\n' +
      '## 9. Acknowledgements\n' +
      '\n' +
      '우리는 디안 벨랑저, 마이클 볼린, 르누카 페르난데스, 네가르 고르바니, 켈리 히라노, 다이애나 슈, 크리스티안 크리스텐센, 킬리안 머피, 크리스 닉슨, 자크 레이, 마셜 로시, 샤힌 세파티, 이루 주 등 메타에서 멀티라인 코드콤포즈 경험을 쌓는데 그들의 노력과 도움, 지원에 감사하고 싶다.\n' +
      '\n' +
      '## References\n' +
      '\n' +
      '* (1)\n' +
      '* 개발 협업 및 모범 사례를 제시하는 대화형 노트. 메타. [https://developers.facebook.com/blog/post220120/90/e/e/elists-bento-interactive-notebook-empowers-development-collaboration-best-practices/] (https://developers.facebook.com/blog/post220120/90/e/e/elists-bento-interactive-notebook-empowers-development-collaboration-best-practices/)\n' +
      '*(2021) GitHub Accessed 2021. _GitHub Coplilot_. GitHub. [https://github.com/features/copilot] (https://github.com/features/copilot)\n' +
      '*(2021) Microsoft Accessed 2021. _Microsoft Intellicode_. 마이크로소프트[https://visualstudio.microsoft.com/services/intellicode] (https://visualstudio.microsoft.com/services/intellicode)\n' +
      '*(2021) Google Accessed 2021. _All Enhanced Code Completion_. Google. [https://ai.googleblog.com/2022/07/ml-enhanced-code-completion-improves.html] (https://ai.googleblog.com/2022/07/ml-enhanced-code-completion-improves.html)\n' +
      '*(2021) Amazon Accessed 2023. _Amazon Code Whisperer_. 아마존. [https://aws.amazon.com/codewhisperer] (https://aws.amazon.com/codewhisperer)\n' +
      '*(2023) Accessed 2023. CodeGuim vs Amazon CodeWhisperer. [https://codetium.com/compare/comparison-codewhisperer-codetium] (https://codetium.com/compare/comparison-codewhisperer-codetium)\n' +
      '*(2023) Accessed 2023. Smart, more efficient coding: GitHub Coplilot is beyond Codex with improved AI model. [https://github.blog/2023-07-28-smarter-more-efficient-coding-github-coplot-goes-beyond-codexwith- improved-ai-model/] (https://github.blog/2023-07-28-Smart-more-efficient-coding-github-coplot-goes-beyond-codexwith- improved-ai-model/)\n' +
      '*(2023) GitHub Accessed 2023. _sfurners_. GitHub. [https://github.com/facebookresearch/sfurners/tree/main/sformers] (https://github.com/facebookresearch/sfurners/tree/main/sformers)\n' +
      '*(2023) Shradda Barke, Michael B. James, and Nadia Polkarpova. 2023. 접지된 코파일럿: 코드 생성 모델을 갖는 프로그래머 인터넷 방법. 도 7, OOPSLA1, Article 78(apr 2023), 27 페이지. [https://doi.org/10.1145/3568030] (https://doi.org/10.1145/3568030)\n' +
      '*(2023) Christian Band, Demaee Ford, Thomas Zimmerman, Nicole Forsgren, Eirini Kalimavukou, Travis Loupdorchurf, Ida Guatiati. 2023. 코파일럿과의 비행: AI로 구동되는 쌍 프로그래밍 도구의 초기 통찰력과 기회. Queue 20, 6(apr 2023), 35-57. [https://doi.org/10.1145/35682083](https://doi.org/10.1145/35682083)\n' +
      '* (2000) Marcel Bruch, Martin Monperrus, and Mira-Merini. 2000. 예제로부터 학습하여 코드 완성 시스템을 개선한다. 유럽 소프트웨어공학회의 제7차 공동회의의 진행과 소프트웨어공학의 기초(ESEC/ENSE \'00_)_에 관한 ACM SIGSOFT 심포지엄에서.\n' +
      '*(2022) Tri Dao, Daniel Y. 푸, 스테파노 에르몬, 아트리 루다, 크리스토퍼 레 2022. FlashAttention: IO-Awareness를 갖는 빠르고 메모리 효율적인 Exact Attention. arXiv:2205.14135 (ESLG)\n' +
      '*(2023) Daniel Fried, Armen Aghajanyan, Jessy Lin, Sida Wang, Ericuke J., Fatek Shi, Ruijg Zhong, Went Wu, Ihike Zettlemoyer, and Mike Lewis. 2023. 로코더: 코드 주입 및 합성을 위한 생성 모델. arXiv:2204.05999 (cs.SI)\n' +
      '*(2021) 김세보휴, 짐만 자오, 유치 톈, 사티쉬 찬드라. 2021. 변환을 위한 트리 공급에 의한 코드 예측. _2021 IEEE ACM International Conference on Software Engineering (ICSE)_. 150-162. [https://doi.org/10.1109/ICSE34902.2021.00026](https://doi.org/10.1109/ICSE34902.2021.00026)\n' +
      '*(2022) Vijayraghavan Marisal, Chandra Maddila, Imad Ahmad, Michael Bolin, Daniel Cheng, Negar Ghorbani, Renuka Fernandez, Nachiappan Nagappan, Peter C Gigy. 2024. A-보조 코드 저작 규모: 미세 조정, 배포 및 혼합 방법 평가. In _Proceedings of the Foundations of Software Engineering (FSE\'24)_.\n' +
      '* (2022) Nham Nguyen and Sarah Nadi. 2022. GitHub 부조종사의 코드 제안에 대한 실증적 평가. In _Proceedings of the 19th International Conference on Mining Software Repositories (MSR\'22)_.\n' +
      '* (2015) Sebastian Frolosch, Johannes Lerch, and Mira Mezini. 2015. 베이지안 네트워크를 이용한 지능형 코드 완성 _ ACM Transactions on Software Engineering and Methodology (TOSEM)_25, 1, 3조 (12 2015).\n' +
      '*(2008) R. 로울스와 M. 로라 2008. 프로그램 히스토리가 코드 완성도를 향상시킬 수 있는 방법 2008년 제32회 IEEE/ACM International Conference on Automated Software Engineering_. 317-326. [https://doi.org/10.1109/ASE.2008.42](https://doi.org/10.1109/ASE.2008.42)\n' +
      '*(2008) Baptiste Roozier, Jonas Gehring, Fabian Gloeckie, Itai Gat, Xiaoting Ellen Tan, Jossi Adi, Jingyu Liu, Tal Remez, Jeremy Rapin, ArtyomKozhennikov, Ivan Evtimov, Joanna Bitton, Manish Bhatt, Cristian Canton Ferrer, Aaron Grattafiori, Wenhan Xiong, Alexandre Defossez, Jade Copet, Faisal Azhar, Hugo Touvron, Louis Martin, Nicolas Usunier, Thomas Scialom, Gabriel Synnaeve. 2023. 코드 라마: 코드에 대한 개방 기초 모델. arXiv:2038.12950 [cs.CL].\n' +
      '* Shan et al. (2022) Qianhua Shan, David Sukhdeo, Qianying Huang, Seth Rogers, Lawrence Chen, Elise Paradis, Peter C. Rigby, and Nachiappan Nagappan. 2022. 넛지를 사용하여 스케일(ESEC/TSE 2022)에서 코드 리뷰를 가속화한다. Association for Computing Machinery, New York, NY, USA, 472-482. [https://doi.org/10.1145/3540250.3549104](https://doi.org/10.1145/3540250.3549104)\n' +
      '* Vaithalingam et al. (2022) Priyan Vaithalingam, Tianyi Zhang, and Elena L. 글래스먼 2022. 기대 vs. 경험: 대규모 언어 모델에 의해 구동되는 코드 생성 도구의 사용성 평가 _Extended Abstracts of 2022 CHI Conference on Human Factors in Computing Systems (CHI EA\'22)_.\n' +
      '* Zhou et al. (2022) Wen Zhou, Seolyn Kim, Vijayanghavan Murali, and Gareth Ari Aye. 2022. 전이학습으로 코드 자동완성 개선. _2022 IEEE/ACM 44th International Conference on Software Engineering: Software Engineering in Practice(ICSE-SEIP)_. 161-162. [https://doi.org/10.1145/3510457.3513061](https://doi.org/10.1145/3510457.3513061)\n' +
      '\n';
  </script>
  <style>
    #content {
      max-width: 800px;
      margin: auto;
    }
  </style>
  <script>
    let script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/mathpix-markdown-it@1.0.40/es5/bundle.js";
    document.head.append(script);

    script.onload = function() {
      const isLoaded = window.loadMathJax();
      if (isLoaded) {
        console.log('Styles loaded!')
      }

      const el = window.document.getElementById('content-text');
      if (el) {
        const options = {
          htmlTags: true
        };
        const html = window.render(text, options);
        el.outerHTML = html;
      }
    };
  </script>
</head>
<body>
  <div id="content"><div id="content-text"></div></div>
</body>
</html>