<!DOCTYPE html>
<html lang="en" data-lt-installed="true"><head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    const text = '' +
      '[MISSING_PAGE_FAIL:1]\n' +
      '\n' +
      'instruction-following (Fu et al., 2019; Zhang et al., 2023a). 또한 에이전트는 다양한 도구를 장착할 수 있지만 이러한 도구는 추가적인 불확실성(예: 데이터베이스 또는 인터넷에 대한 접근성)을 유발한다. 다중 에이전트 시스템 견고성의 관점에서, 하나의 예상치 못한 오류 또는 응답이 전체 시스템으로 전파될 수 있고, 적절하게 처리되지 않으면 일련의 연쇄적 효과를 야기할 수 있다. 따라서 다중 에이전트 응용 프로그램이 LLM의 잘못된 응답을 자율적으로 감지하고 처리하는 것이 중요하다. LLM이 이러한 오류를 식별하고 관리하는 데 도움이 될 수 있지만, 자체적으로 오류를 해결할 수 있는지 여부를 결정하고 오류 정정에 필요한 정보를 자동으로 제공하는 것은 여전히 과제로 남아 있다. 결과적으로, LLM을 통합하는 결함 허용을 설계하는 것은 다중 에이전트 응용 프로그램 개발의 핵심 과제이다.\n' +
      '\n' +
      '매우 체계적인 멀티모달 데이터__Compatible multi-modal data is highly systematic.__Compatible multi-modal data 멀티모달 콘텐츠 생성을 목표로 하는 에이전트 또는 LLM 애플리케이션의 수가 증가하고 있다. 멀티-에이전트 애플리케이션에서 멀티-모달 데이터(Su et al., 2023; Betker et al., 2023)를 지원하는 것은 포괄적이고 체계적인 접근법을 필요로 한다. 여기에는 데이터 저장, 프리젠테이션, 사용자 상호 작용, 메시지 전송, 통신 등에 대한 고려 사항이 포함된다. 그러나 이러한 요구 사항을 충족시키는 것은 새로운 과제를 제시하고, 다른 포맷에 걸쳐 데이터 일관성을 보장하고, 데이터 전송 및 에이전트 통신 동안 높은 성능을 유지하며, 개발자와 사용자 모두에게 복잡한 개념의 도입을 피하는 것을 포함한다. 애플리케이션별 솔루션이 있지만, 멀티모달 애플리케이션을 지원하기 위한 일반적인 플랫폼 수준의 프로그래밍 인터페이스는 없다.\n' +
      '\n' +
      '_분산 애플리케이션은 여분의 프로그래밍 어려움과 시스템 설계 문제를 가져온다.__ 다중 에이전트 애플리케이션에 대한 산업 중심의 시나리오는 에이전트가 고유한 개인 지식 또는 특허받은 도구를 갖추고 있기 때문에 에이전트가 다른 조직에 의해 소유되고 다른 기계에서 실행된다는 것이다. 이러한 응용 프로그램을 지원하기 위해서는 일반적으로 응용 프로그램 개발자가 설계 단계에서 분산 시스템 프로그래밍 및 최적화에 대한 전문적인 지식을 갖추어야 한다. 또한, 분산 응용 프로그램은 특히 분산 프로세스 또는 에이전트에 분산되어 있는 문제를 디버깅하고 진단할 때 개발 및 테스트에 많은 추가 노력을 필요로 한다. 또한, 멀티모달 데이터 처리와 같은 고급 기능을 통합하는 것은 분산 환경에서 추가적인 문제를 제기하는데, 에이전트가 서브 태스크를 수행하는 데 다른 시간을 요구하거나 생성된 콘텐츠가 매우 이질적이다. 잘못된 설계 결정은 에이전트 간의 과도한 통신 오버헤드를 초래할 수 있습니다. 따라서 개발자는 효과적인 시스템 운영을 보장하기 위해 이러한 문제를 효과적으로 해결하는 것이 어렵다.\n' +
      '\n' +
      '이러한 문제를 해결하기 위해 다양한 수준의 전문성을 가진 개발자를 위해 설계된 새로운 멀티 에이전트 플랫폼인 **에이전트스코프**를 소개합니다. 에이전트스코프는 큰 사용성, 견고성 및 효율성을 구현하는 메시지 교환 통신 메커니즘으로 잘 설계되었다. 우리는 다음과 같이 AgentScope의 두드러진 특징을 강조한다:\n' +
      '\n' +
      '**개발자를 위한 예외적인 사용성**: AgentScope는 특히 다양한 수준의 전문 지식을 가진 개발자를 위해 사용 용이성을 근본적으로 강조하여 설계되었습니다. 프로시저 중심의 메시지 교환 메커니즘을 구현함으로써 AgentScope는 원활한 학습 곡선을 보장한다. 에이전트스코프는 프로그래밍 부담을 완화하기 위해 다양한 파이프라인 및 정보 공유 메커니즘을 포함한 광범위한 구문 유틸리티 세트를 제공한다. 풍부한 내장 리소스 및 통합 사용자 상호 작용 모듈과 결합된 에이전트스코프는 멀티 에이전트 애플리케이션 프로그래밍을 그 어느 때보다 훨씬 더 즐겁게 만듭니다.\n' +
      '\n' +
      '**다양한 LLM 및 API에 대한 강력한 결함 내성**: 모델 및 API의 규모와 범위가 확장됨에 따라 다중 에이전트 응용에서 강력한 결함 내성 메커니즘이 가장 중요해진다. 에이전트스코프는 포괄적인 서비스 수준 재시도 메커니즘을 통합하여 API 신뢰성을 유지합니다. 에이전트스코프는 LLM의 응답에서 일부 명백한 포맷팅 문제를 처리하기 위해 규칙 기반 수정 도구 세트를 갖추고 있다. 또한 AgentScope는 사용자 정의 가능한 결함 허용 구성을 제공하여 개발자가 parse_func, fault_handler 및 max_retries와 같은 매개변수를 통해 자신의 결함 허용 메커니즘을 조정할 수 있다. 비록 모든 오류들이 앞서 언급한 메커니즘으로 처리될 수 있는 것은 아니지만, 우리는 AgentScope에 대한 마지막 보호 장치로 다중 에이전트 애플리케이션을 위한 맞춤형 기능을 가진 로깅 시스템을 제안한다.\n' +
      '\n' +
      '**멀티-모달 애플리케이션에 대한 광범위한 호환성**: 대규모 멀티-모달 모델의 현저한 진보로 AgentScope는 대화 표현, 메시지 전송 및 데이터 저장 모두에서 멀티-모달 데이터(_e.g._, 파일, 이미지, 오디오 및 비디오)를 지원한다. 특히, AgentScope는 메시지 내의 통합된 URL 기반 속성에 의해 스토리지로부터 다중 모달 데이터 전송을 분리한다. 메시지 전송 중에 AgentScope는 메시지에 URL만 첨부하므로 각 에이전트의 메모리에서 메시지 복사본으로 인해 발생하는 메모리 사용량을 최소화할 수 있습니다. 이 전략은 웹 UI에서 렌더링되거나 모델 래퍼에 의해 호출될 때와 같이 필요한 경우에만 멀티모달 데이터가 로드되도록 한다.\n' +
      '\n' +
      '**분산 다중 에이전트 운영을 위한 최적화된 효율성**: 분산 배포의 중요한 중요성을 인식한 AgentScope는 복잡한 분산 워크플로우의 중앙 집중식 프로그래밍과 자동 병렬 최적화를 가능하게 하는 액터 기반 분산 메커니즘을 도입합니다. 특히, 로컬 및 분산 배포에 대한 워크플로우는 정확히 동일하여 중앙 집중식 및 분산 환경 간에 응용프로그램을 마이그레이션할 때 무시할 수 있는 오버헤드를 나타냅니다. 이러한 배포 프레임워크를 통해 에이전트스코프는 개발자가 구현 세부 사항보다 애플리케이션 설계에 집중할 수 있도록 한다.\n' +
      '\n' +
      '요약.**을 요약하면, 본 논문에서 제안하는 에이전트스코프 멀티 에이전트 플랫폼은 다중 에이전트 프로그래밍을 용이하게 하기 위해 구문적 특징을 갖는 절차 지향적인 메시지 교환 메커니즘을 제공한다; 에이전트스코프의 결함 허용 설계는 개발자가 자신의 애플리케이션에 대해 우아하게 오류를 처리할 수 있게 한다; 멀티모달 애플리케이션에 대한 지원은 이질적인 데이터 생성 및 전송의 오버헤드를 줄인다; 에이전트스코프의 행위자 기반 분산 모드는 효율적이고 신뢰성 있는 분산 멀티 에이전트 애플리케이션을 원활하게 개발할 수 있게 한다.\n' +
      '\n' +
      '**로드맵.** 다음 섹션에서 에이전트스코프의 핵심 구성 요소와 기능을 탐색하여 멀티 에이전트 애플리케이션의 개발 및 배포를 촉진하는 역할을 보여준다. 섹션 2는 개요를 제공하는 반면 섹션 3은 사용자 경험에 중점을 둔다. 섹션 6은 우리 플랫폼의 분산 효율성을 조사합니다. 섹션 5와 4는 다중 모드 지원 및 고장 허용을 포함합니다. 제7절에서는 활용 사례를, 제8절에서는 관련 작업을, 제9절에서는 생각을 마무리한다.\n' +
      '\n' +
      '## 2 Overview\n' +
      '\n' +
      'AgentScope의 기본 개념###\n' +
      '\n' +
      '이 절에서는 에이전트스코프의 기본 개념인 메시지, 에이전트, 서비스 및 워크플로우에 대해 설명합니다. 이 네 가지 개념은 플랫폼 전체에 걸쳐 있으며 이를 기반으로 하는 모든 멀티 에이전트 응용 프로그램이다.\n' +
      '\n' +
      '***Message**: 메시지는 정보의 소스와 내용을 캡슐화하여 멀티 에이전트 대화에서 정보 교환을 위한 캐리어 역할을 한다. AgentScope에서 메시지는 두 개의 필수 필드(_name_ 및 _content_)와 선택적 필드(_url_)를 갖는 파이썬 사전으로 구현된다. _name_ 필드는 메시지를 생성한 에이전트의 이름을 기록하고, _content_ 필드는 에이전트에 의해 생성된 텍스트 기반 정보를 포함한다. _url_ 필드는 URL(Uniform Resource Locator)을 보유하도록 설계되며, URL은 통상적으로 이미지 또는 비디오와 같은 멀티모달 데이터에 링크된다. 이 필드가 있는 메시지는 멀티 모달을 처리하고 생성할 수 있는 에이전트와의 상호 작용에 특히 관련이 있습니다.\n' +
      '\n' +
      '도 1: AgentScope의 아키텍처.\n' +
      '\n' +
      '컨텐츠. 각각의 메시지는 자동 생성된 UUID 및 타임스탬프에 의해 고유하게 식별되어 추적성을 보장한다. 예제 1은 에이전트스코프의 에이전트 간 통신에서 원자 역할을 하는 메시지가 생성될 수 있는 방법을 보여준다.\n' +
      '\n' +
      '```\n' +
      '1fromagentscope.messageimportMsg\n' +
      '2\n' +
      '3msg1=Msg("Alice","Hello1")\n' +
      '4msg2=Msg(\n' +
      '5name="Bob",\n' +
      '6content="HowdoyoufindthispictureIcapturedyesterday?",\n' +
      '7url="[https://xxx.png](https://xxx.png)")\n' +
      '```\n' +
      '\n' +
      '예제 1: 에이전트스코프에서 메시지 작성 예제\n' +
      '\n' +
      '에이전트는 멀티 에이전트 애플리케이션 내의 주요 행위자로서 대화 참가자 및 태스크의 실행자 역할을 한다. 에이전트스코프에서 에이전트 동작은 _reply_와 _observe_ 함수의 두 가지 인터페이스를 통해 추상화된다. _reply_ 함수는 메시지를 입력으로 하여 응답을 생성하는 반면, _observe_ 함수는 직접 응답을 생성하지 않고 착신 메시지를 처리한다. 예제 2와 같이 에이전트와 메시지 간의 상호 작용은 에이전트스코프의 운영 기반을 형성하며 개발자가 다중 에이전트 LLM에서 복잡한 상호 작용을 모델링하는 데 필수적이다. [좌마진=0cm]\n' +
      '**Service**: AgentScope에서의 서비스는 에이전트가 특정 작업을 수행할 수 있도록 하는 기능적 API를 지칭한다. 이러한 서비스는 LLM을 사용할 채널인 모델 API 서비스와 다양한 도구 기능을 제공하는 일반 API 서비스로 분류된다. 이러한 서비스를 에이전트에 통합하는 것은 특히 외부 데이터 또는 계산 서비스를 필요로 할 수 있는 LLM과 인터페이스할 때 광범위한 작업을 실행하기 위한 핵심이다.\n' +
      '**워크플로우**: 워크플로우는 텐서플로우의 계산 그래프와 유사하지만 비-DAG 구조를 수용할 수 있는 유연성을 가진 에이전트 실행 및 에이전트 간의 메시지 교환의 순서화된 시퀀스를 나타낸다. 워크플로우는 에이전트 간의 정보 및 작업 처리 흐름을 정의하여 병렬 실행 및 효율성 향상을 촉진합니다. 이 개념은 복잡하고 상호 의존적인 작업의 조정을 허용하기 때문에 LLM과 상호 작용하는 다중 에이전트 시스템을 설계하는 데 필수적이다.\n' +
      '\n' +
      'AgentScope의### 구조\n' +
      '\n' +
      '우리는 LLM과 통합된 다중 에이전트 애플리케이션의 생성, 관리 및 배포를 용이하게 하기 위한 인프라 플랫폼으로 AgentScope를 제시한다. 에이전트스코프의 아키텍처는 도 1에 도시된 바와 같이, 세 개의 계층 계층으로 구성된다. 계층들은 단일 에이전트(유틸리티 계층), 리소스 및 런타임 관리(관리자 및 래퍼 계층), 및 에이전트-레벨 내지 워크플로우-레벨 프로그래밍 인터페이스(에이전트 계층)를 포함하는 상이한 레벨들로부터의 멀티-에이전트 애플리케이션들에 대한 지원을 제공한다. 에이전트스코프는 다중 에이전트 시스템을 구축할 때 각 계층에 내재된 다양한 기능을 수행하고 복잡한 계층 간 종속성을 단순화하기 위해 설계된 직관적인 추상화를 도입한다. 또한, 다양한 계층 내의 장애에 대한 다중 에이전트 시스템의 복원력을 강화하기 위한 프로그래밍 인터페이스와 기본 메커니즘을 제공한다.\n' +
      '\n' +
      '**유틸리티 계층:** 플랫폼의 토대로서, AgentScope 내의 유틸리티 계층은 에이전트의 핵심 기능을 지원하기 위해 필수적인 서비스를 제공한다. 이 계층은 API 호출, 데이터 검색 및 코드 실행과 같은 기본 작업의 복잡성을 추상화하여 에이전트가 기본 작업에 집중할 수 있도록 합니다. 에이전트스코프의 유틸리티 계층은 사용의 용이성과 견고성을 최우선으로 하여 설계되었으며, 멀티 에이전트 시스템에서 다용도 동작을 지원하고 예기치 않은 인터럽션에 대한 예외 및 오류 처리를 위한 _built-in_ 자율 재시도 메커니즘을 제공한다.\n' +
      '\n' +
      '**관리자 및 래퍼 계층:** 중개자로서 관리자 및 래퍼 추상화 계층은 리소스 및 API 서비스를 관리하여 리소스의 높은 가용성을 보장하고 LLMs로부터의 원하지 않는 응답에 대한 저항을 제공한다. 디폴트 핸들러를 제공하는 유틸리티 레이어와 달리, 관리자 및 래퍼 레이어는 또한 개발자의 요구 및 애플리케이션의 특정 요구 사항에 따라 결함 허용 제어를 위한 사용자 지정 가능한 인터페이스를 제공한다. 이 계층은 LLM이 다양한 조건에서 일관되게 수행하는 중요한 측면인 에이전트의 운영 무결성을 유지하는 역할을 한다. 결함 허용 메커니즘에 대한 자세한 설명은 섹션 4에 나와 있다.\n' +
      '\n' +
      '**에이전트 계층:**에이전트 스코프의 핵심에는 에이전트 추상화가 있으며, 이는 다중 에이전트 워크플로우의 백본을 형성하며 상호 작용 및 통신을 담당하는 주요 엔티티입니다. 이 레이어는 복잡한 워크플로우의 구성을 용이하게 하고 사용성을 향상시켜 개발자의 프로그래밍 부담을 줄이도록 설계되었습니다. 에이전트스코프는 간소화된 구문 및 도구를 통합함으로써 개발자가 LLM의 기능을 활용하는 에이전트 기반 애플리케이션의 구현 및 최적화에 집중할 수 있도록 한다. 프로그래밍 기능과 구문 당은 섹션 3에 더 자세히 소개되어 있다.\n' +
      '\n' +
      '**사용자 상호 작용:** 계층화된 아키텍처 외에도, AgentScope는 단말 및 웹 UI와 같은 다중 에이전트 지향 인터페이스를 제공한다. 이러한 인터페이스를 통해 개발자는 에이전트 통신, 실행 시기 및 금융 비용을 포함하여 애플리케이션의 상태 및 메트릭을 효과적으로 모니터링할 수 있다.\n' +
      '\n' +
      '종합적으로 AgentScope의 계층 구조는 개발자가 대규모 언어 모델의 고급 기능을 활용하는 맞춤형 멀티 에이전트 애플리케이션을 제작할 수 있는 필수 구성 요소를 제공한다. 후속 섹션에서는 멀티 에이전트 애플리케이션 개발을 위한 프로그래밍 경험을 향상시키는 에이전트스코프의 기능을 조사할 것이다.\n' +
      '\n' +
      '##3 AgentScope의 높은 사용성\n' +
      '\n' +
      '에이전트스코프의 설계는 LLM을 가진 멀티 에이전트의 개발 프로세스를 간소화하고 사용자와 개발자 모두에게 원활한 상호 작용 경험을 보장하는 것을 목표로 사용성을 우선시한다. 이 섹션에서는 에이전트스코프가 복잡한 다중 에이전트 애플리케이션의 생성을 용이하게 하는 직관적인 개념과 기능을 도입하여 학습 곡선을 평평하게 하고 프로그래머의 경험을 향상시키는 방법을 설명한다.\n' +
      '\n' +
      '다중 에이전트 워크플로우를 위한### 구문당\n' +
      '\n' +
      '섹션 2.1에 소개된 기본 개념을 활용하여 개발자는 정교한 멀티 에이전트 애플리케이션을 구성할 수 있는 권한을 부여받는다. 그럼에도 불구하고, 각각의 에이전트의 메시지 교환을 직접 코딩하는 것은 실시예 3에 도시된 바와 같이 번거로워질 수 있다. 이를 인식하고, AgentScope는 복잡성을 추상화하고 반복을 최소화하기 위해 파이프라인 및 메시지 허브라는 두 가지 구문적 유틸리티를 도입한다.\n' +
      '\n' +
      '```\n' +
      '1#setupagents:agent1toagent5\n' +
      '2#...\n' +
      '3\n' +
      '4x=agent1(x)\n' +
      '5x=agent2(x)\n' +
      '6x=agent3(x)\n' +
      '7x=agent4(x)\n' +
      '8x=agent5(x)\n' +
      '```\n' +
      '\n' +
      '예제 3: 에이전트스코프에서 기본 개념으로 순차적 워크플로우를 프로그래밍하는 예제\n' +
      '\n' +
      '** 파이프라인 추상화:** 파이프라인 추상화는 순차적, 조건부 및 반복적 교환을 포함하는 메시지 전송의 패턴을 단순하고 재사용 가능한 컴포넌트로 캡슐화함으로써 반복적인 코딩을 감소시킨다. 파이프라인을 사용하면 개발자는 상용구 코드보다 에이전트 상호 작용의 논리에 집중할 수 있다. 예제 4는 파이프라인이 명확하고 간결한 에이전트 워크플로우를 생성하기 위해 기능 및 객체 지향 스타일 모두에서 사용될 수 있는 방법을 보여줍니다. 예제의 순차적 파이프라인 외에도 AgentScope는 if-else, switch, while-loop 및 for-loop 파이프라인도 제공하여 다중 에이전트 상호 작용의 프로그래밍을 용이하게 한다.\n' +
      '\n' +
      '```\n' +
      '1#setupagents:agent1toagent5\n' +
      '2#...\n' +
      '3fromagentscope.pipelinesimportSequentialPipeline\n' +
      '4fromagentscope.pipelines.functionalimportsequentialpipeline\n' +
      '5\n' +
      '6#usingfunctionalpipeline\n' +
      '7x=sequentialpipeline([agent1,agent2,agent3,agent4,agent5],x)\n' +
      '8\n' +
      '9#usingobjectpipeline\n' +
      '10pipe=SequentialPipeline([agent1,agent2,agent3,agent4,agent5])\n' +
      '11x=pipe(x)\n' +
      '```\n' +
      '\n' +
      '예제 4: 에이전트스코프에서 워크플로우를 구성하기 위해 기능 및 객체 순차 파이프라인을 사용합니다.\n' +
      '\n' +
      '**에이전트 통신을 위한 메시지 허브:** 다중 에이전트 시스템에서 특히 LLM과 통합될 때, 에이전트 그룹 간의 통신을 효율적으로 관리하는 것이 필수적이다. 에이전트스코프의 메시지 허브는 그룹 상호 작용을 단순화하는 브로드캐스트 메커니즘 역할을 한다. 개발자들은 참여 에이전트들을 정의함으로써 메시지 허브를 개시할 수 있고, 초기 브로드캐스트 메시지들을 포함할 수 있다. 새로운 메시지들이 메시지 허브 내의 에이전트들에 의해 생성될 때, 이들은 예 5에서 입증된 바와 같이, 다른 참가자들에게 자동으로 전파된다. 이러한 추상화는 LLM들을 수반하는 멀티-에이전트 시나리오들에 특히 유용하며, 여기서 동적 및 맥락적으로 풍부한 대화들은 공통 Du 등(2023)이다.\n' +
      '\n' +
      '```\n' +
      '1#setupagents:agent1toagent4\n' +
      '2#...\n' +
      '3\n' +
      '4greeting=Mag("host","Welcometothemessagehub!")\n' +
      '5\n' +
      '6withmsghub(participant=[agent1,agent2,agent3],\n' +
      '7announcement=greeting)ashub:\n' +
      '8#Messagewillbebroadcasttoagent2andagent3automatically\n' +
      '9agent1()\n' +
      '10\n' +
      '11#Deleteagent2fromthemessagehub\n' +
      '12hub.delete(agent2)\n' +
      '13\n' +
      '14#Addagent4intothemessagehub\n' +
      '15hub.add(agent4)\n' +
      '16\n' +
      '17#Broadcastmessage\n' +
      '18hub.broadcast(Mag("host","Welcomagent4tojointthehub!"))\n' +
      '```\n' +
      '\n' +
      '예제 5: 에이전트스코프와 함께 메시지 허브를 사용합니다.\n' +
      '\n' +
      '### 에이전트 개발을 위한 자원이 풍부한 환경\n' +
      '\n' +
      '사용성을 더욱 향상시키기 위해, AgentScope에는 서비스, 전용 에이전트 및 사전 구성된 예를 포함한 풍부한 내장 리소스 세트가 장착되어 있습니다. 이러한 리소스는 초기 설정 노력을 줄이고 다중 에이전트 LLM 시스템의 신속한 프로토타이핑 및 배치를 가능하게 하도록 설계되었다.\n' +
      '\n' +
      '** 종합 서비스 통합:** 에이전트스코프는 에이전트의 기능을 지원하기 위해 웹 검색, 데이터베이스 조회, 코드 실행 등 다양한 서비스를 통합한다. 이러한 서비스는 종종 외부 소스에서 정보를 가져오거나 장착된 LLM의 내부 지식을 넘어서는 작업을 수행해야 하기 때문에 LLM을 사용하여 유용한 에이전트를 구축하는 데 필수적이다. 예 6은 오픈AI 호환 JSON 형식으로 서비스를 원활하게 변환하여 개발자를 위한 통합 프로세스를 단순화한 것을 보여준다.\n' +
      '\n' +
      '**사전 구축된 에이전트 템플릿:** 표 1에 카탈로그화된 바와 같이, 에이전트스코프는 대화 관리, 사용자 프록시, 멀티모달 데이터 처리 및 분산 배포와 같은 작업에 대해 사전 구축된 에이전트 및 즉시 사용 가능한 구성 요소를 제공합니다. 이러한 템플릿은 개발자가 커스터마이징하고 확장할 수 있는 출발점 역할을 하여 다중 에이전트 LLM 애플리케이션의 개발을 크게 가속화한다.\n' +
      '\n' +
      '### 다중 에이전트 지향 상호작용 인터페이스\n' +
      '\n' +
      '또한, 에이전트스코프는 도 2, 도 3 및 도 4에 도시된 바와 같이 다중 에이전트 시스템에 맞춘 상호작용 인터페이스를 도입한다. 이러한 인터페이스는 다양한 데이터 유형을 다루는 LLM을 통합하는 시스템에 중요한 풍부한 멀티모달 경험을 제공한다.\n' +
      '\n' +
      '**사용자 인터페이스의 에이전트 차별화:** 여러 에이전트와의 사용자 상호 작용을 용이하게 하기 위해 AgentScope는 각 에이전트에 고유한 색상과 아이콘을 할당하여 단말기 및 웹 UI 모두에서 선명도와 시각적 구분을 강화한다. "1인칭 관점" 기능은 사용자가 게임 시나리오와 같은 애플리케이션에서의 역할과 일치하면서 지정된 에이전트의 관점에서 상호 작용을 경험할 수 있게 한다. 이 기능은 다중 에이전트 경험을 풍부하게 할 뿐만 아니라 LLM 시스템 내의 인간 에이전트 및 에이전트 에이전트 대화에서 발생하는 미묘한 상호 작용을 반영한다.\n' +
      '\n' +
      '**모니터링 및 비용 관리:** LLM을 대규모로 배치하는 중요한 측면은 리소스 관리입니다. 에이전트스코프는 금융 비용 계산뿐만 아니라 모델 및 API 사용량을 추적하는 모니터링 모듈을 포함한다. 개발자는 메트릭을 사용자 정의하고 예산 제한을 설정할 수 있으며 임계값 시 자동 경고를 받을 수 있습니다.\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l|l} \\hline \\hline Agent Name & Function \\\\ \\hline UserAgent & The proxy of the user. \\\\ DialogAgent & A general dialog agent, whose role can be set by system prompt. \\\\ DictDialogAgent & A dictionary version dialog agent, who responds in Python dictionary format. \\\\ ProgrammerAgent & An agent that can write and execute Python code. \\\\ TextToImageAgent & An agent that generates images according to the requirements. \\\\ AudioDialogAgent & An agent that can interact in speech. \\\\ RpcUserAgent & A distributed version user proxy. \\\\ RpcDialogAgent & A distributed version DialogAgent. \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      '표 1: AgentScope에 내장된 에이전트 및 그 기능.\n' +
      '\n' +
      '접근되었거나 초과되었습니다. 이러한 사전적인 비용 관리는 높은 계산 비용을 초래할 수 있는 LLM에 특히 중요하다.\n' +
      '\n' +
      '본질적으로 AgentScope는 개발자가 결함 허용 다중 에이전트 LLM 애플리케이션을 효율적으로 구축하고 배포할 수 있는 환경을 제공한다. 에이전트스코프는 구문 추상화, 풍부한 리소스 풀 및 다중 에이전트 대화형 인터페이스를 제공함으로써 다중 에이전트 시스템의 복잡성을 추상화하여 개발자가 혁신적인 솔루션을 만드는 데 집중할 수 있도록 한다.\n' +
      '\n' +
      '##4 결함허용 메커니즘 지원\n' +
      '\n' +
      '다중 에이전트 시스템, 특히 다양한 오픈 소스 LLM과 연동하는 시스템에서 결함 허용성은 원활한 동작을 보장하기 위한 핵심 속성이다. 에이전트스코프는 다중 에이전트 조정 및 LLM 의존성과 관련된 복잡성을 심각하게 인식하는 포괄적인 결함 내성 인프라를 기반으로 필요한 최소한의 인간 개입으로 광범위한 오류를 자율적으로 처리하도록 설계되었다.\n' +
      '\n' +
      '오류 분류 및 처리 전략.우리의 접근법은 각각 맞춤형 처리 전략을 갖는 별개의 레벨로 오류를 체계적으로 분류하는 것으로 시작한다:\n' +
      '\n' +
      '*_접근성 오류:_ AgentScope에서, 에이전트의 기능들은 상이한 종류의 서비스들에 의존하지만, 그러한 서비스들은 일시적인 접근불가 오류들의 대상이 될 수 있다. 이러한 오류는 모델 불안정성 또는 네트워크 상태에 의해 발생할 수 있다. 예를 들어, 모델 API들은 존재하는 경우 타임아웃 에러를 리턴할 수 있다\n' +
      '\n' +
      '그림 3: AgentScope에서 늑대인간 게임의 대화 이력.\n' +
      '\n' +
      '그림 2: AgentScope에서 Multi-modal 데이터의 생성, 저장 및 전송.\n' +
      '\n' +
      '통화 중 시간에 트래픽 혼잡이 발생하거나 일시적인 네트워크 중단으로 인해 원격 컴퓨터의 데이터베이스에 액세스할 수 없습니다.\n' +
      '* _Rule-resolvable error:_ 많은 멀티 에이전트 애플리케이션들이 서비스들 또는 에이전트들 간의 정보 교환을 요구하기 때문에, 그러한 통신들에 대한 프로토콜들, 예를 들어, JSON 포맷으로 따르는 것이 필수적이다. 그러나 LLM의 응답이 아직 완전히 제어 가능하지 않기 때문에 반환이 프롬프트에서 필요한 형식을 따르지 않을 수 있다. 예를 들어, JSON의 LLM에서 응답을 기대할 수 있지만 리턴이 끝날 때 오른쪽 브레이스가 누락되어 구문 분석 실패로 이어진다.\n' +
      '*_Model-resolvable error:_멀티 에이전트 시스템이 몇 가지 복잡한 작업을 처리할 때, 에이전트가 입력을 이해하고 결정을 내리고 출력을 전달하는 능력은 대부분 LLM의 능력에 달려 있다. LLM의 응답은 예상된 형식인 경우도 있지만, 내용에는 논증 오류, 의미 오류 또는 프로그래밍 오류와 같은 문제가 있다. 다양한 작업에 대한 응답을 정규화하기 위해 미리 정의된 규칙을 갖는 것은 어렵지만, 이러한 오류는 LLM과의 추가 상호 작용에 의해 감지되고 복구될 수 있음을 보여주었다.\n' +
      '*_Unresolvable error:_결국, 검출되거나 해결될 수 없는 약간의 error가 있어야 한다. 대표적인 예는 LLM의 API 키가 만료되었거나 승인되지 않은 경우이다. 에이전트 또는 시스템에 의존하는 에이전트는 이러한 오류를 해결하기 위해 아무것도 할 수 없습니다.\n' +
      '\n' +
      '에이전트스코프의 결함 허용 메커니즘.에이전트스코프에서는 위에서 언급한 오류에 대처할 수 있는 다양한 메커니즘을 제공한다.\n' +
      '\n' +
      '* _Basic auto-retry mechanism._ 접근성 오류를 방지하기 위해 에이전트스코프의 API 서비스와 모델 래퍼는 최대 재시도 횟수를 설정하는 등 개발자가 사용자 정의할 수 있는 재시도 로직으로 강화된다. 이렇게 하면 에이전트가 산발적인 중단에서 회복하고 운영 연속성을 유지할 수 있습니다.\n' +
      '* _Rule 기반 보정도구._ 규칙 기반 수정 도구는 에이전트스코프에 도입되어 LLM의 응답에서 수정하기 쉬운 형식 오류를 효율적이고 경제적으로 처리할 수 있다. 예를 들어, 일치할 수 없는 가새를 완료하고 문자열에서 JSON 데이터를 추출할 수 있는 에이전트스코프의 기본 규칙 세트를 설정합니다. 이러한 규칙 기반 수정 도구는 LLM API를 다시 호출하지 않고도 공통 규칙 해결 가능한 오류 중 일부를 수정할 수 있으며, 이는 처리 시간이 짧고 LLM API 호출 비용이 없음을 의미한다.\n' +
      '\n' +
      '그림 4: 웹 UI에서 에이전트 간의 멀티모달 상호 작용.\n' +
      '\n' +
      '*_Customizable fault handlelers._ 에이전트스코프는 또한 개발자가 LLM의 응답을 분석하고 예상치 못한 출력을 처리하는 방법을 정의하기 위해 모델 래퍼에 유연한 결함 처리기 인터페이스를 통합한다. 응용 프로그램 개발자는 LLM을 호출할 때 구성 가능한 매개변수, parse_func 및 fault_handler 및 max_retries를 통해 구문 분석 기능, 결함 처리 기능 및 LLM에 부여하는 기회 수를 제공하여 결함 처리 메커니즘을 구성할 수 있다. 이러한 개발자 친화적인 설계로 AgentScope는 규칙 해결 가능한 오류(빌드인 규칙이 처리하지 못할 때) 및 단일 에이전트에 의해 탐지 및 처리될 수 있는 일부 모델 해결 가능한 오류(예: 장황한 요약이 보다 간결한 것으로 증류)에 구성 가능하게 견고할 수 있다.\n' +
      '* _Agent-level fault handling._ 복구하려면 더 고급 LLM 사용 또는 에이전트 수준 상호 작용이 필요한 모델 해결 가능한 오류가 있습니다. 예를 들어, 일반적으로 사실적 부정확성, 논리적 불일치, 맥락적 일관성, 불합리한 추론 및 부적절한 어휘 사용을 포함하는 의미론적 오류를 검출하는 것은 시스템의 기존 검증 프로세스 내에서 즉각적인 적색 플래그를 반드시 트리거하지 않을 수 있기 때문에 어렵다. 개발자는 에이전트스코프(예: 메모리 모듈 및 메시지 허브)에서 에이전트의 능력을 활용하여 자체 비평, 쌍별 비평 및 인간-증강 비평과 같은 의미 오류 검사를 위해 비평할 수 있다.\n' +
      '* _Logging system._ 해결할 수 없는 오류는 시스템이 처리하기에는 너무 까다롭지만, AgentScope는 개발자가 멀티 에이전트 응용 프로그램의 문제를 신속하게 모니터링하고 식별할 수 있도록 개선된 로깅 시스템을 제공한다. 에이전트스코프에서의 로깅 시스템은 에이전트들 간의 대화를 로깅하기 위한 CHAT라는 로깅 레벨을 추가하고, 다양한 실행 정보를 갖는 포맷된 로그를 제공하고, 모니터링을 용이하게 하기 위한 WebUI 사용자 인터페이스를 포함하는 멀티 에이전트 애플리케이션 시나리오들에 대한 맞춤화된 특징들을 갖는다.\n' +
      '\n' +
      '멀티모달 어플리케이션을 지원하는##5\n' +
      '\n' +
      '멀티모달 데이터의 통합은 LLM과 멀티 에이전트의 기능 및 응용 프로그램을 발전시키기 위해 필수적이다. 에이전트스코프는 현대 LLM이 처리하고 생산할 수 있는 다양한 입력과 출력을 활용하여 다양한 데이터 양식을 원활하게 지원하도록 설계되었다.\n' +
      '\n' +
      '실행 중인 에이전트스코프 응용 프로그램에서 다중 모달 데이터의 관리는 다중 모달 데이터의 라이프사이클을 신중하게 관리합니다. 이 관리에는 다중 모달 데이터의 생성, 전송 및 저장이 포함되며, 모두 URL을 사용하는 디커플드 아키텍처와 로컬 파일 관리자 시스템을 통해 용이해진다. 도. 도 2는 사용자 입력 또는 모델 생성으로부터 유래하는 데이터, 데이터 저장 및 검색 및 데이터 공유를 포함하는 이러한 프로세스를 예시한다.\n' +
      '\n' +
      '* _Multi-modal data generation._ 에이전트스코프에는 두 가지 주요 다중 모드 데이터 소스가 있습니다. 하나의 소스는 단순히 로컬 파일 시스템에 액세스하는 사용자 프록시 에이전트 또는 일반 에이전트에 의해 사용될 수 있는 로컬 저장된 멀티모달 파일이다. 또 다른 소스는 모델-모달 콘텐츠 생성 모델이다. 모델 API와 모델 래퍼는 OpenAI의 DALL-E와 같은 텍스트 대 이미지 콘텐츠 생성 모델과 같은 가장 인기 있는 다중 모델 모델을 통합하고, 반대로 GPT-4V와 같은 이미지 대 텍스트 이미지 분석 모델을 통합한다. 내장 API 외에도 개발자는 바로 사용할 수 있는 예를 시작으로 좋아하는 멀티모달 모델을 소개하고 자체 모델 래퍼를 사용자 정의할 수 있다. 이 사용자 정의 프로세스는 에이전트스코프에서 간소화되고 모듈식 설계의 이점을 제공하여 개발자가 최소한의 노력으로 멀티모달 서비스를 연결할 수 있습니다.\n' +
      '* _Multi-modal data storage._ 전술한 바와 같이, 멀티 에이전트 애플리케이션에서의 멀티모달 데이터는 바로 사용할 수 있는 로컬 파일로부터 또는 멀티모달 모델에 의해 생성될 수 있다. 멀티모달 모델 래퍼를 호출하여 멀티모달 데이터를 생성하면, 먼저 파일 관리자의 도움을 받아 데이터를 로컬로 저장하고, 모델 API 서비스로부터 멀티모달 데이터를 수신하면 로컬 URL을 반환한다.\n' +
      '* _Multi-modal data transmission._ 에이전트스코프는 에이전트가 데이터의 실제 저장 위치를 나타내기 위해 로컬 또는 원격 URL을 멀티모달 메시지로 캡슐화할 수 있게 함으로써 에이전트 간의 멀티모달 데이터 공유 프로세스를 단순화한다. 수신기 에이전트는 이를 처리할 준비가 되면 URL을 통해 멀티모달 데이터를 로드할 수 있다.\n' +
      '\n' +
      '에이전트가 다중 모드 데이터를 공유할 때 메시지에 URL을 도입하는 이점은 3배입니다. 1) 네트워크 대역폭으로 인한 잠재적인 오류 또는 지연을 방지하고 수신자 에이전트가 요구 시 데이터를 로드할 수 있도록 메시지 크기를 최소화할 수 있다. 2) 메시지 내에 다른 텍스트 정보가 있는 경우, 다운스트림 에이전트들은 잠재적으로 텍스트 정보의 프로세싱을 멀티-모달 정보의 프로세싱에 우선순위를 매기거나 병렬화할 수 있다. 3) 이러한 URL-부착 메시지는 또한 멀티-모달 데이터 데모를 용이하게 할 수 있으며, 이는 다음 섹션에서 소개될 것이다.\n' +
      '\n' +
      '다중-모달 상호작용 모드는 URL이 부착된 메시지의 구현으로, 에이전트스코프는 사용자가 단말기 및 웹 UI와 같은 액세스 가능한 인터페이스를 통해 다중-모달 시스템과 상호작용할 수 있게 한다. 그림 4는 상호작용 모드 내에서 멀티모달 데이터와 상호작용하는 사용자의 능력을 보여준다. 단말기에서, 사용자들은 제공된 URL들을 활성화함으로써 로컬로 저장된 데이터에 편리하게 액세스할 수 있다. 웹 UI는 현대 웹 애플리케이션의 기대에 맞춰 멀티모달 콘텐츠를 보고 분석할 수 있는 직관적인 플랫폼을 제공함으로써 사용자 경험을 더욱 향상시킨다.\n' +
      '\n' +
      '에이전트스코프를 통해 개발자는 모델 API 서비스와 래퍼를 개인의 필요에 맞게 조정하고 다양한 데이터 양식을 처리하는 애플리케이션을 위조하며 사용자에게 멀티모달 에이전트와 효과적으로 결합할 수 있는 필요한 도구를 제공한다. 멀티모달 애플리케이션에 대한 이러한 포괄적인 지원은 에이전트스코프를 멀티 에이전트 LLM의 잠재력을 최대한 활용하기 위한 다재다능하고 강력한 프레임워크로 배치하여 정교하고 상호 작용하는 AI 시스템을 만드는 데 있어 개발자와 연구자 모두에게 지평을 넓힌다.\n' +
      '\n' +
      '##6 액터기반 분산 프레임워크\n' +
      '\n' +
      '다중 에이전트 시스템에서 산업 수준의 응용프로그램을 구축할 때 효율성과 확장성이 필수적입니다. 다중 에이전트 애플리케이션에서 에이전트의 추론 속도는 극적으로 변할 수 있다. 예를 들어, 멀티모달 애플리케이션의 에이전트가 텍스트 대 비디오 모델을 채용한다고 가정하자. 그 경우, 그 응답 시간은 이야기의 세부 사항을 채우도록 설계된 에이전트의 응답 시간보다 상당히 길 수 있다. _ 평행화는 고전적인 아이디어로서 효율성을 높이기 위해 도입되어야 한다. 게다가, 멀티 에이전트 애플리케이션은 서로 다른 머신에 물리적으로 분산된 에이전트를 포함할 수 있다. 전형적인 사용 사례는 기업이 특허받은 기술이나 개인 지식 기반을 인터넷에 연결된 로컬 기계에서 에이전트로 포장하고 에이전트 상호 작용을 통해 다른 엔티티에 자율적인 서비스를 제공할 수 있다는 것이다.\n' +
      '\n' +
      '그러나 멀티 에이전트 시스템의 경우 개발자가 다음 두 쌍의 기술 로드맵 사이에서 결정을 내려야 하는 문제가 있다. 무료 점심이 없기 때문에 어떤 조합도 장단점이 있습니다.\n' +
      '\n' +
      '* _Centralized v.s. decentralized coordination._ 분산 시스템의 맥락에서, 중앙 집중식 조정은 서버-클라이언트 모델과 같은 중앙 노드에 의해 관리되는 다수의 계산 노드를 의미한다. 중앙 집중식 조정을 갖는 다중 에이전트 메커니즘은 에이전트의 실행이 중앙 조정 컴포넌트에 의해 스케줄링되고 에이전트 간의 메시지가 중앙 조정 컴포넌트에 의해 포워딩되는 것을 의미한다. 반대로, 분산형 조정은 메시지를 스케줄링하거나 전달하기 위해 임의의 중앙 컴포넌트에 의존하지 않지만, 그러한 시스템의 에이전트는 자동으로 호출될 수 있고 추가 처리를 위해 다운스트림 에이전트에게 메시지를 직접 전송할 수 있다. 중앙 집중식 조정은 이해할 수 있고 디버깅하기 쉬운 간단한 스타일이지만, 그것의 단점은 중앙 노드 장애에 대한 취약성, 중앙 노드에 많은 트래픽을 부과하고, 스케일링 또는 복잡한 애플리케이션으로의 확장의 어려움을 포함한다. 대조적으로, 분산형 조정은 개발 및 유지를 위한 추가 노력이 필요할 수 있지만 단일 노드의 장애에 대해 더 높은 견고성을 갖는다.\n' +
      '*_정적 vs. 동적 워크플로우 설계._ TensorFlow(Abadi et al., 2016)의 초기 버전에서 사용된 정적 계산 그래프와 PyTorch Paszke et al.(2019)에서 사용된 동적 계산 그래프 간에 유사한 비교가 발견될 수 있다. 다중 에이전트 애플리케이션의 맥락에서, 정적 워크플로우와 동적 워크플로우 사이의 선택은 미리 컴파일된 실행과 해석된 실행 사이에서 선택하는 것과 유사하다. 정적 워크플로우 설계는 실행 시간 및 리소스 할당을 위한 워크플로우 그래프 레벨의 최적화를 가능하게 할 수 있다. 그러나 정적 워크플로우 설계는 실행 전에 워크플로우 그래프를 알아야 하므로 응용프로그램, 특히 설계에 루프 구조가 있는 응용프로그램으로의 적응을 제한한다. 대조적으로, 동적 워크플로우는 최적화 잠재력을 희생시키면서 더 큰 유연성을 제공합니다. 이는 입력 데이터 또는 모델 추론 결과에 기초하여 실행 경로가 변경될 수 있는 큰 언어 모델을 다룰 때 특히 관련이 있다.\n' +
      '\n' +
      '에이전트스코프에서의 분산 모드.에이전트스코프는 다중 에이전트 LLM 시스템의 고유한 요구를 염두에 둔 액터 기반 분산 모드를 구현함으로써 이러한 기술 로드맵의 균형을 맞추고, 다음과 같은 중요한 특징을 갖는다:\n' +
      '\n' +
      '*_정적 그래프 없는 자동 병렬 최적화_ 에이전트스코프는 액터 모델을 활용하여 자동 병렬 최적화를 가능하게 하여 개발자가 정적 그래프 프로그래밍의 복잡성을 피할 수 있게 한다. 이 접근법은 LLM의 동적 및 종종 예측할 수 없는 특성과 원활하게 정렬되며, 여기서 계산 그래프는 진화하는 컨텍스트 및 대화 상태에 기초하여 변경될 수 있다.\n' +
      '*_복잡도를 최소화한 프로그래밍 워크플로우._ 분산 에이전트에 대한 복잡한 실행 순서를 요구하는 전통적인 액터 모델 및 P2P(Peer-to-Peer) 구현과 달리, AgentScope는 워크플로우 프로그래밍을 파이썬 함수 내의 단일 절차 스타일로 단순화한다. 이 디자인은 개발자에게 학습 곡선을 상당히 평평하게 하여 정교한 다중 에이전트 LLM의 구성에 더 쉽게 접근할 수 있도록 한다.\n' +
      '*_Hybrid local and distributed agent support._ 에이전트스코프의 유연성은 일부 에이전트가 로컬로 동작하는 반면 다른 에이전트는 분산되는 하이브리드 모드를 지원하는 것으로 확장된다. 이 기능은 다양한 계산 요구 사항을 가진 LLM을 통합할 때 특히 유용하며, 구현 중에 개발자가 둘 사이를 구별할 필요 없이 덜 까다로운 에이전트가 로컬로 유지되는 동안 리소스 집약적 모델이 배포될 수 있도록 한다.\n' +
      '\n' +
      '구체적으로, 우리는 에이전트스코프가 어떻게 행위자 모델을 통합하는지를 다음과 같이 간결하게 설명할 수 있다. 이 개념적 프레임워크에서 "액터"는 필요한 모든 메시지를 수신하면 계산을 처리하는 독립 실행형 엔터티 역할을 한다. 이 패러다임은 액터에 해당하는 각 에이전트가 필요한 입력 메시지가 준비되면 계산에만 관여하여 자동 병렬 최적화를 달성하도록 보장한다.\n' +
      '\n' +
      '그러나, 액터-모델 기반 워크플로우는 프로그래밍 챌린지를 제시한다: 액터들(즉, 에이전트들) 사이를 통과하는 변수(즉, 메시지들)는 초기에 어떠한 실질적인 의미도 없이 플레이스홀더일 수 있다. 를 포함하고,\n' +
      '\n' +
      '도 5: 에이전트스코프에서의 분산 애플리케이션의 예로서, 상이한 컬러들로 표시된 바와 같은 다양한 프로세스들을 예시한다.\n' +
      '\n' +
      '이를 완화하면, AgentScope는 실제 값을 나중에 검색하는 데 필요한 정보를 보존하면서 주요 프로세스를 차단하지 않고 계속할 수 있는 새로운 데이터 구조인 "플레이스홀더" 메시지를 소개한다(도 5). 이 메커니즘은 실행 흐름이 언어 모델의 가변 출력에 적응해야 하는 다중 에이전트 LLM 시스템에 특히 유리하다.\n' +
      '\n' +
      '```\n' +
      '1#setupdistributedagent:agent\n' +
      '2...\n' +
      '3\n' +
      '4input_msg=Mag("system","Whichagentshouldrespondnext,agent2oragent37")\n' +
      '5\n' +
      '6#thevariablechoceisaplecholder\n' +
      '7choice:placeholder=host_agent(input_msg)\n' +
      '8\n' +
      '9ifchoice["content"]=="agent2":\n' +
      '10response=agent2()\n' +
      '11elifchoice["content"]=="agent3":\n' +
      '12response=agent3()\n' +
      '```\n' +
      '\n' +
      '예제 7: 에이전트스코프 내의 제어 흐름에서 플레이스홀더의 사용을 입증합니다.\n' +
      '\n' +
      '플레이스홀더가 실제 값 없이 제어 흐름 문장(예: if-else, 루프) 내에서 사용될 때 또 다른 일련의 문제가 발생한다. 예제 7에 예시가 표시되며, 여기서 플레이스홀더는 결정을 내리기 위해 필요하다. 이러한 상황에서 AgentScope는 실제 값을 검색하기 위해 프로세스를 일시적으로 차단하여 제어 흐름의 연속성을 보장한다.\n' +
      '\n' +
      '에이전트스코프에서 액터 기반 분산 모드는 자동 병렬 최적화를 제공하고 개발자 경험을 단순화할 뿐만 아니라 분산 다중 에이전트 LLM 응용 프로그램에 대해 높은 효율성을 보여준다. 개발자는 기본 분산 복잡성에 대한 우려 없이 에이전트 로직, 특히 "응답" 기능을 구현하는 데 집중할 수 있다. 분산 멀티 에이전트 시스템에 대한 이러한 간소화된 접근 방식은 정교하고 확장 가능한 멀티 에이전트 아키텍처를 보다 쉽게 개발, 실행 및 디버깅할 수 있도록 함으로써 LLM의 분야를 발전시킬 수 있다.\n' +
      '\n' +
      '## 7 Applications\n' +
      '\n' +
      '에이전트스코프는 대규모 모델을 사용자 친화적이고 결함 허용 방식으로 통합하고 조정하기 위해 최적화된 멀티 에이전트 플랫폼으로 자리 잡고 있다. 위에서 언급한 기능을 통해 AgentScope는 다양한 응용 분야에 이상적인 플랫폼입니다. 단순 대화에서 웨어울프와 같은 복잡한 규칙 기반 게임에 이르기까지 여러 기계에 걸친 병렬 작업을 포함하는 분산 대화까지 다양합니다. 이 섹션에서는 에이전트스코프의 세 가지 주요 응용 프로그램을 확장하며 각 인스턴스는 프레임워크의 고유한 기능을 설명한다. 여기에서 참조된 모든 예는 커뮤니티 사용 및 기여를 위해 GitHub 저장소에서 액세스할 수 있다.\n' +
      '\n' +
      '### Standalone Conversation\n' +
      '\n' +
      '에이전트스코프의 근본적인 적용은 모든 에이전트가 주요 프로세스에서 작동하는 독립형 대화를 촉진하는 데 있다. 이 유스 케이스는 에이전트스코프를 처음 접하는 사용자에게 훌륭한 출발점이 되어 프레임워크의 기본 기능에 익숙해질 수 있다.\n' +
      '\n' +
      '애플리케이션을 론칭하는 초기 단계는 에이전트 객체들을 초기화하는 것을 포함한다. 이 예에서는 사용자와 AI 어시스턴트 간의 대화를 용이하게 하기 위해 에이전트스코프 내에 두 개의 내장 에이전트인 DialogAgent와 UserAgent를 활용한다. 이러한 에이전트를 인스턴스화하기 전에 에이전트스코프의 시작 인터페이스를 통해 모델 구성을 로드해야 합니다. 현재 AgentScope는 표준 OpenAI chat, embedding 및 DALL-E API, HuggingFace 및 ModelScope 추론 API뿐만 아니라 FastChat, vllm 또는 Flask를 사용하여 로컬 호스트된 모델을 포함한 다양한 플랫폼과 호환된다. 추가로, init 인터페이스는 파일 저장 디렉토리, 저장 옵션, 로깅 레벨 및 에이전트 구성 등을 지정할 수 있게 한다. 모델 구성을 설정한 후, 개발자는 예 8에 예시된 바와 같이 각각의 모델로 에이전트를 인스턴스화할 수 있다.\n' +
      '\n' +
      '```\n' +
      '1importagentscope\n' +
      '2fromagentscope.agentsimportDialogAgent,UserAgent\n' +
      '3\n' +
      '4#readmodelconfigs\n' +
      '5agentscope.init(model_configs="./openai_model_configs.json")\n' +
      '6\n' +
      '7#Createadiologagentandauseragent\n' +
      '8assistant_agent=DialogAgent(\n' +
      '9name="Assistant",\n' +
      '10sys_prompt="Youareahelpfullassistant",\n' +
      '11model="gpt-4"\n' +
      '12}\n' +
      '13user_agent=UserAgent()\n' +
      '```\n' +
      '\n' +
      '예 8: AgentScope에서 독립형 대화 예제의 간단한 초기화.\n' +
      '\n' +
      '```\n' +
      '1#Basicversion\n' +
      '2x=None\n' +
      '3whilexisNoneorx.content!="exit":\n' +
      '4x=assistant_agent(x)\n' +
      '5x=user_agent(x)\n' +
      '```\n' +
      '\n' +
      '예 9: 에이전트스코프의 독립 실행형 대화 응용 프로그램입니다.\n' +
      '\n' +
      '이후 에이전트들 간에 메시지를 교환하여 대화를 구성한다. 구체적으로, 대화 프로세스는 루프가 되도록 설계되어, 사용자가 대화를 마무리하는 것을 선택할 때까지 연속적인 상호작용을 허용한다. 예 9는 에이전트스코프 내의 기본 구현들을 예시한다.\n' +
      '\n' +
      '보다 진보된 애플리케이션을 수용하기 위해, AgentScope는 메시지 교환을 관리하기 위해 파이프라인을 통합함으로써 복잡한 에이전트 상호 작용을 위한 구조화되고 확장 가능한 프레임워크를 제공한다. 여기서, 이 독립형 대화 애플리케이션의 구현은 예 10)에 도시된 바와 같이 순차 파이프라인 및 루프 파이프라인으로 단순화될 수 있다. 나아가, 부록 A는 상기 코드를 실행하여 대화 이력을 제시한다.\n' +
      '\n' +
      '```\n' +
      '1#Advancedversionwithsequentialpipeline\n' +
      '2fromagentscope.pipelines.functionalimportsequentialpipeline\n' +
      '3x=None\n' +
      '4whilexisNoneorx.content!="exit":\n' +
      '5x=sequentialpipeline([dialog_agent,user_agent],x)\n' +
      '6\n' +
      '7#Advancedversionwithwhilelooppipeline\n' +
      '8fromagentscope.pipelines.functionalimportwhilelooppipeline\n' +
      '9x=whilelooppipeline(\n' +
      '10[assistant_agent,user_agent],\n' +
      '11condition_func=lambda_,x:xisNoneorx.content!="exit",\n' +
      '12x=None)\n' +
      '```\n' +
      '\n' +
      '예제 10: 파이프라인과의 독립 실행형 대화.\n' +
      '\n' +
      '### Werewolf\n' +
      '\n' +
      '보다 복잡한 응용 프로그램으로 발전하여 이 하위 섹션에서는 약 100줄의 코드로 에이전트스코프에서 웨어울프 게임의 워크플로를 프로그래밍하는 방법을 보여준다. 늑대인간 게임은 사회공제 게임으로 6명의 선수가 상대팀인 늑대인간과 마을사람으로 나뉘어 진행된다. 모든 늑대인간이 제거되거나(마을의 승리) 늑대인간 수가 마을사람과 같거나(늑대인간 승리) 숫자보다 많을 때 게임이 끝난다.\n' +
      '\n' +
      '게임 설정에는 역할 할당 및 에이전트 초기화가 포함됩니다. 에이전트 스코프는 에이전트 개체를 인스턴스화하는 데 필요한 매개 변수가 포함된 미리 설정된 에이전트 구성으로 빠른 시작을 지원합니다.\n' +
      '\n' +
      '예제 11은 구성으로부터 에이전트를 로드하고 역할을 할당하는 방법을 보여줍니다.\n' +
      '\n' +
      '늑대인간 게임에서 가장 눈에 띄는 특징 중 하나는 야간 단계 및 주간 토론에서 늑대인간 토론을 포함하여 그룹 대화이며, 이는 여러 다른 플레이어가 참여해야 한다. 이러한 요구사항을 해결하기 위해 에이전트스코프의 메시지 허브를 활용하여 그룹 대화를 쉽게 생성할 수 있다. 예시 12는 에이전트스코프에서 구현된 늑대인간 토론을 제시한다. 이 토론에서 메시지 허브는 진행자의 안내 멘트로 시작합니다. 그 후, 늑대인간은 최대 MAX_WEREWOLF_DISCUSSION_ROUND 라운드에 대해 논의하고 합의에 도달하면 결론을 내린다. 늑대인간 게임에서 사용되는 에이전트 클래스는 Python 사전에서 응답하는 DictDialogAgent이다. 에이전트에게 "동의" 필드를 사용하여 응답하라는 프롬프트로 응답 메시지에서 이 속성을 직접 사용할 수 있습니다. 전체 코드 및 예시 대화 내역은 부록 B를 참조하시기 바랍니다.\n' +
      '\n' +
      '### Distributed Conversation\n' +
      '\n' +
      '분산 에이전트를 허용하는 것은 에이전트스코프에서 가장 눈에 띄는 기능 중 하나입니다. 이 하위 섹션에서는 단일 기계 다중 프로세스 모드와 다중 기계 다중 프로세스 모드의 두 가지 모드로 분산 애플리케이션을 설정하는 방법을 자세히 설명한다.\n' +
      '\n' +
      '단일 기계 다중 프로세스 모드에서 모든 에이전트는 개별 프로세스에서 실행되는 단일 기계에 배치됩니다. 비교를 위해 독립형 대화로 동일한 예를 구현하지만 자체 프로세스 내에 배치된 보조 에이전트와 함께 구현한다. 예 13은 완전 코드를 나타내며, 로컬 배포와의 유일한 차이는 to_dist 함수의 호출이다. 이후 에이전트는 자동으로 할당된 포트로 로컬 호스트에 배포됩니다. 이 외에도 단일 머신 멀티 프로세스 모드는 로컬 배포와 본질적으로 동일하지만 병렬 실행을 위해 최적화되었습니다.\n' +
      '\n' +
      '대조적으로, 멀티 머신 멀티 프로세스 모드는 개발자들이 원격 머신에서 에이전트 서비스를 개시할 것을 요구한다. 예 14는 원격 컴퓨터에서 다이얼로그 에이전트 배포의 예를 보여주고 예 15는 멀티 머신 멀티 프로세스 모드에서 워크플로우를 구성하는 방법을 자세히 설명합니다. 이 경우 개발자는 지정된 URL과 포트를 사용하여 에이전트 서버에 연결한 다음 워크플로우를 구성해야 합니다. 단일 컴퓨터 다중 프로세스 모드와 유사하게 워크플로우 코드는 로컬 배포와 동일합니다.\n' +
      '\n' +
      '```\n' +
      '1fromagentscope.agentsimportUserAgent,DialogAgent\n' +
      '2importagentscope\n' +
      '3\n' +
      '4agentscope.init(model_configs=model_configs)\n' +
      '5\n' +
      '6assistant_agent=DialogAgent(\n' +
      '7name="Assistant",\n' +
      '8sys_prompt="Youareahelpfullassistant",\n' +
      '9model="gpt-4"\n' +
      '10).to_dist()\n' +
      '11user_agent=UserAgent()\n' +
      '12\n' +
      '13x=None\n' +
      '14whilexisNoneornotx.content!="exit:\n' +
      '15x=sequentialpipeline([assistant_agent,user_agent],x)\n' +
      '```\n' +
      '\n' +
      '예 13: 에이전트스코프의 분산 대화 애플리케이션.\n' +
      '\n' +
      '```\n' +
      '1fromagentscope.agents:rpc_agentimportRpcAgentServerLauncher\n' +
      '2fromagentscope.agentsimportDialogAgent\n' +
      '3\n' +
      '4#Loadmodelconfigurations\n' +
      '5agentscope.init(model_configs="configs/model_configs.json")\n' +
      '6\n' +
      '7server_launcher=RpcAgentServerLauncher(\n' +
      '8agent_class=DialogAgent,\n' +
      '9agent_kwargs={\n' +
      '10"name":"Assistant",\n' +
      '11"sys_prompt":"Youareahelpfullassistant.",\n' +
      '12"model":"gpt-4"\n' +
      '13},host="xxx.xxx.xxx",\n' +
      '15port=12010,\n' +
      '16)\n' +
      '17\n' +
      '18#Starttheserver\n' +
      '19server_launcher.launch()\n' +
      '20server_launcher.wait_until_terminate()\n' +
      '```\n' +
      '\n' +
      '예 14: 원격 컴퓨터에서 에이전트 서버를 시작합니다.\n' +
      '\n' +
      '요약하면, 본 프레임워크는 분산 배포가 로컬 배포와 동일한 워크플로우 구성을 활용할 수 있도록 하여 분산 애플리케이션의 개발을 단순화하고 로컬에서 분산 모드로의 원활한 전환을 용이하게 한다.\n' +
      '\n' +
      '##8 관련 작품\n' +
      '\n' +
      '에이전트스코프의 개발은 언어 에이전트 및 다중 에이전트 시스템의 생성을 위해 대규모 언어 모델(LLM)을 활용하는 프레임워크의 빠르게 진화하는 환경과 일치한다. 본 논문에서는 에이전트 범위(AgentScope)와 관련된 두 가지 하위 도메인인 언어 에이전트 프레임워크(Language Agent Framework)와 다중 에이전트 간의 협업을 강조하는 다중 에이전트 프레임워크(Multi Agent Framework)를 소개한다. 더 광범위한 관련 저작물에 대해서는 독자들이 참조할 수 있다(Wang et al., 2023; Xi et al., 2023).\n' +
      '\n' +
      '언어 에이전트 프레임워크 언어 에이전트 프레임워크는 인간 언어를 사용하여 해석하고 상호 작용할 수 있는 애플리케이션을 개발하는 데 중추적이다.\n' +
      '\n' +
      '트랜스포머 라이브러리(Huggingface, 2023)는 최근 업데이트(_Transformers-Agents_)에서 트랜스포머 모델과 인터페이스하기 위해 자연어 API를 도입하였다. 이 API는 사용자 지정 가능한 도구 세트를 사용하여 모델이 명령을 해석하고 그에 따라 코드 스니펫을 생성할 수 있습니다. 다양한 오픈 소스 및 독점 모델 엔드포인트에 대한 지원을 제공하며 다양한 개발자의 요구에 부응합니다. _ LangChain_(Langchain-AI, 2023)는 상황인지 및 추론이 가능한 애플리케이션을 구축하기 위한 프레임워크를 제공한다. 여기에는 여러 구성 요소를 통일된 인지 아키텍처로 통합하기 쉬운 라이브러리 및 템플릿이 포함됩니다. LangServe와 LangSmith는 REST API로 배포를 가능하게 하고 모든 LLM 프레임워크에 구축된 체인을 디버깅 및 모니터링하기 위한 개발자 도구를 제공함으로써 프레임워크의 기능을 확장한다. _ AutoGPT_(AutoGPT-Team, 2023)는 다른 접근법을 예시하여, LLM이 동작을 반복적으로 실행하고 결정을 내릴 수 있게 한다. AutoGPT는 일반 에이전트로서 태스크 특정이 아니며, LLM의 적응 특성을 반영하여 다양한 컴퓨터 기반 태스크를 수행하도록 설계되었다. _ ModelScope-Agent_(Li et al., 2023a)는 오픈 소스 LLM을 활용하여 작업을 수행하고 외부 API와 연결하는 맞춤형 에이전트 프레임워크이다. 데이터 수집, 도구 검색 및 맞춤형 모델 교육을 위한 포괄적인 인프라를 제공하면서 모델 API 및 공통 API와의 원활한 통합을 용이하게 하며, 모두 실제 응용 프로그램을 실현하는 것을 목표로 한다.\n' +
      '\n' +
      '다중 에이전트 프레임워크는 개별 에이전트의 기능을 기반으로 여러 에이전트 간의 협업 및 상호 작용을 탐색하여 복잡한 작업을 해결한다.\n' +
      '\n' +
      '(Wu et al., 2023)은 개발자가 자연어와 코드를 모두 사용하여 상호 작용 패턴을 프로그래밍할 수 있는 일반적인 인프라를 제공한다. 이 프레임워크는 커스터마이징이 가능한 에이전트 간의 대화를 용이하게 하여 다양한 애플리케이션의 개발을 가능하게 하며 LLM, 인간 입력 및 도구의 다양한 조합을 활용할 수 있다. _ MetaGPT_(Hong et al., 2023)는 멀티 에이전트 협업을 향상시키기 위해 메타 프로그래밍을 통합한다. 표준화된 운영 절차(SOP)를 프롬프트로 인코딩하여 이 프레임워크는 간소화된 워크플로우와 오류 감소를 보장하여 에이전트 간의 효과적인 작업 분해를 보여줍니다. _ AGENTS_(Zhou et al., 2023)는 계획, 메모리, 멀티 에이전트 통신과 같은 특징을 가진 자율 언어 에이전트를 지원하는 오픈 소스 라이브러리이다. 사용자 친화적이고, 비전문가들이 최첨단 언어 에이전트를 배치할 수 있도록 돕고, 확장성을 위한 모듈화된 설계로 연구 친화적이도록 설계되었다. _ OpenAgents_(Xie et al., 2023)는 웹 인터페이스를 통해 액세스 가능한 실용적인 기능을 가진 언어 에이전트를 사용하기 위한 개방형 플랫폼을 제공한다. 이 프레임워크는 실제 에이전트 상호 작용의 촉진을 강조하고 데이터 분석 및 웹 브라우징과 같은 서로 다른 작업에 대한 전문 에이전트를 포함한다. _ ChatDev_(Qian et al., 2023)는 소프트웨어 개발을 위해 LLM을 활용하여 폭포 모델을 따르는 가상 채팅 기반 회사를 만든다. 개발 프로세스의 여러 단계에서 "소프트웨어 에이전트"를 참여시켜 협업 및 상황 인식 커뮤니케이션을 촉진합니다. _ CAMEL_(Li et al., 2023b)는 에이전트 행동 및 능력을 연구하기 위한 대화 데이터를 생성할 수 있는 역할 재생 기술을 사용하여 통신 에이전트 간의 자율적 협력을 위한 새로운 프레임워크를 제안한다. 마지막으로 _AgentSims_(Lin et al., 2023)는 태스크 기반 시나리오에서 LLM을 평가하기 위해 샌드박스 환경을 도입하여 연구자가 시뮬레이션된 환경 내에서 특정 LLM 용량을 테스트할 수 있는 인프라를 제공한다.\n' +
      '\n' +
      '이러한 프레임워크는 개별 및 협력 에이전트 작업 모두에 대한 LLM의 사용에서 상당한 발전을 나타낸다. 에이전트스코프는 이러한 컨텍스트 내에 위치하여 다중 에이전트 LLM 시스템에 내재된 복잡한 상호 작용 및 프로세스를 관리하도록 설계된 사용자 친화적이고 결함 허용적이며 다재다능한 프레임워크의 필요성을 해결함으로써 기여한다. 에이전트스코프는 사용의 용이성과 신뢰성에 중점을 둠으로써 다양한 도메인에 걸쳐 견고하고 다재다능한 애플리케이션의 생성을 용이하게 하는 것을 목표로 한다.\n' +
      '\n' +
      'Conclusion\n' +
      '\n' +
      '본 연구에서는 다중 에이전트 시스템 개발의 최전선에 서 있는 플랫폼인 AgentScope를 제안하여 LLM의 고급 기능과 사용자 중심의 설계를 시너지 효과를 발휘한다. 에이전트스코프는 혁신적인 통신 및 분산 메커니즘을 통해 에이전트 간의 협업을 촉진하여 효율적인 결함 허용 작업 및 다중 모드 상호 작용을 가능하게 할 수 있는 잠재력을 보여준다. 복잡성을 추상화하고 다양한 개발 유틸리티를 제공함으로써 에이전트스코프는 진입 장벽을 실질적으로 낮추어 개발자의 보다 포괄적이고 창의적인 커뮤니티를 육성한다.\n' +
      '\n' +
      '향후, AgentScope는 추가 연구 및 개발을 위한 수많은 길을 열어준다. 향후 작업은 검색 증강 생성의 더 깊은 통합을 조사하고 작업 요구 사항과 함께 진화하는 적응형 통신 프로토콜 및 대화형 모드를 탐색할 수 있다. 헬스케어에서 고객 서비스에 이르기까지 산업 전반에 걸쳐 다중 에이전트 시스템의 배치를 가속화하는 플랫폼의 영향은 심각할 것이며 잠재적으로 인간-기계 협업을 향상시키는 더 똑똑하고 반응성이 높은 기술로 이어질 것이다. 에이전트스코프를 통해 보다 광범위한 연구 개발 커뮤니티를 기반으로 하여 차세대 지능형 멀티 에이전트 애플리케이션을 형성할 혁신을 주도합니다.\n' +
      '\n' +
      '## References\n' +
      '\n' +
      '* Abadi et al. (2016) Martin Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irving, Michael Isard, et al. {TensorFlow}: a system for {Large-Scale} machine learning. 제12회 USENIX 심포지엄에서 운영 체제 설계 및 구현(OSDI 16)_, 페이지 265-283, 2016.\n' +
      '* Autoogpt(2023) AutoGPT-Team. Autogpt, 2023. URL[https://github.com/Significant-Gravitas/AutoGPT](https://github.com/Significant-Gravitas/AutoGPT).\n' +
      '* Betker et al. (2023) James Betker, Gabriel Goh, Li Jing, Tim Brooks, Jianfeng Wang, Linjie Li, Long Ouyang, Juntang Zhuang, Joyce Lee, Yufei Guo, et al. 더 나은 캡션을 갖는 이미지 생성 개선. _ Computer Science_, 2(3):8, 2023.\n' +
      '* Du et al. (2023) Yilun Du, Shuang Li, Antonio Torralba, Joshua B Tenenbaum, and Igor Mordatch. 다중 에이전트 토론을 통해 언어 모델의 사실성과 추론 능력 향상 arXiv preprint arXiv:2305.14325_, 2023.\n' +
      '* Fu et al. (2019) Justin Fu, Anoop Korattikara, Sergey Levine, and Sergio Guadarrama. 언어에서 목표까지: 비전 기반 수업 후행을 위한 역강화 학습. _7th International Conference on Learning Representations_, 2019.\n' +
      '* Hong et al. (2023) Sirui Hong, Xiawu Zheng, Jonathan Chen, Yuheng Cheng, Jinlin Wang, Ceyao Zhang, Zili Wang, Steven Ka Shing Yau, Zijuan Lin, Liyang Zhou, et al. Metagpt: Meta programming for multi-agent collaborative framework. _ arXiv preprint arXiv:2308.00352_, 2023.\n' +
      '* 허깅페이스(2023) 허깅페이스. Transformers-agents, 2023. URL[https://huggingface.co/docs/transformers/transformers_agents](https://huggingface.co/docs/transformers/transformers_agents)\n' +
      '* 랭체인(2023) 랭체인-AI. Langchain, 2023. URL[https://github.com/langchain-ai/langchain](https://github.com/langchain-ai/langchain].\n' +
      '* Li et al. (2023a) Chenliang Li, Hehong Chen, Ming Yan, Weizhou Shen, Haiyang Xu, Zhikai Wu, Zhicheng Zhang, Wenmeng Zhou, Yingda Chen, Chen Cheng, et al. Modelscope-agent: open-source large language models로 사용자화 가능한 에이전트 시스템을 구축한다. _ arXiv preprint arXiv:2309.00986_, 2023a.\n' +
      '* Li et al. (2023b) Guohao Li, Hasan Abed Al Kader Hammoud, Hani Itani, Dmitrii Khizbullin, and Bernard Ghanem. 낙타: 대규모 언어 모델 사회의 "마인드" 탐구를 위한 의사소통 에이전트 _ arXiv preprint arXiv:2303.17760_, 2023b.\n' +
      '* Lin et al. (2023) Jiaju Lin, Haoran Zhao, Aochi Zhang, Yiting Wu, Huqiuyue Ping, and Qin Chen. 에이전트: 대규모 언어 모델 평가를 위한 오픈소스 샌드박스 _ arXiv preprint arXiv:2308.04026_, 2023.\n' +
      '* OpenAI(2023) OpenAI. GPT-4 기술 보고서입니다 CoRR_, abs/2303.08774, 2023.\n' +
      '* Ouyang et al. (2022) Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul F. Christiano, Jan Leike, and Ryan Lowe. 인간의 피드백으로 지침을 따르도록 언어 모델을 훈련합니다. In _Advances in Neural Information Processing Systems 35: Annual Conference on Neural Information Processing Systems_, 2022.\n' +
      '* Park et al. (2023) Joon Sung Park, Joseph C. O\'Brien, Carrie Jun Cai, Meredith Ringel Morris, Percy Liang, and Michael S. 번스틴 생성 에이전트: 인간 행동의 상호 작용 시뮬라크라. _Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology_, pages 2:1-2:22, 2023.\n' +
      '* Paszke et al. (2019) Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Kimelshein, Luca Antiga, et al. Pytorch: An imperative style, high performance deep learning library. _ 신경 정보 처리 시스템_, 32, 2019의 발전.\n' +
      '* Qian et al. (2023) Chen Qian, Xin Cong, Cheng Yang, Weize Chen, Yusheng Su, Juyuan Xu, Zhiyuan Liu, and Maosong Sun. 소프트웨어 개발을 위한 통신 에이전트. _ arXiv preprint arXiv:2307.07924_, 2023.\n' +
      '* Qian et al. (2023)* Rawte et al. (2023) Vipula Rawte, Amit P. Sheth, and Amitava Das. 대형 기초모델에서의 환각에 대한 조사 CoRR_, abs/2309.05922, 2023.\n' +
      '* Su et al. (2023) Weijie Su, Xizhou Zhu, Chenxin Tao, Lewei Lu, Bin Li, Gao Huang, Yu Qiao, Xiaogang Wang, Jie Zhou, 및 Jifeng Dai. 멀티모달 상호 정보의 극대화를 통한 올인원 사전 교육에 대한 것입니다. _IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pages 15888-15899, 2023.\n' +
      '* Touvron et al. (2023) Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timothee Lacroix, Baptiste Roziere, Naman Goyal, Eric Hambro, Faisal Azhar, Aurelien Rodriguez, Armand Joulin, Edouard Grave, and Guillaume Lample. 개방적이고 효율적인 기초 언어 모델 CoRR_, abs/2302.13971, 2023a.\n' +
      '* Touvron et al. (2021) Hugo Touvron, Louis Martin, Kevin Stone, Likel, Likas Blecher, Cristian Canton-Ferrer, Moya Bhosale, David Esiobu, Jude Almahairi, Jeremy Fu, Wenyin Fu, Bynthia Gao, Vedan Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Vindan Kardas, Viktor Kerkez, Miedan Lavril, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Lavril, Yixin Nie, Likan Leean Larov, Yiaia Williams, Riaia Subramanian Tan, Binh Tang, Ross Taylor, Adina Williams, Jiaia Zaran Zarov, Sharan Narang, Aurelien Rodriguez, Robert Stojnic 라마 2: 오픈 파운데이션 및 미세 조정 채팅 모델들_ CoRR_, abs/2307.09288, 2023b.\n' +
      '* Wang et al. (2023) Lei Wang, Chen Ma, Xueyang Feng, Zeyu Zhang, Hao Yang, Jingsen Zhang, Zhiyuan Chen, Jiakai Tang, Xu Chen, Yankai Lin, et al. A survey on large language model based autonomous agents. _ arXiv preprint arXiv:2308.11432_, 2023.\n' +
      '* Wu et al. (2023) Qingyun Wu, Gagan Banal, Jieyu Zhang, Yiran Wu, Shaokun Zhang, Erkang Zhu, Beibin Li, Li Jiang, Xiaoyun Zhang, and Chi Wang. 자동 생성: 다중 에이전트 대화 프레임워크를 통해 차세대 llm 응용 프로그램을 활성화합니다. _ arXiv preprint arXiv:2308.08155_, 2023.\n' +
      '* Xi et al. (2023) Zhiheng Xi, Wenxiang Chen, Xin Guo, Wei He, Yiwen Ding, Boyang Hong, Ming Zhang, Junzhe Wang, Senjie Jin, Enyu Zhou, et al. The rise and potential of large language model based agents: A survey. _ arXiv preprint arXiv:2309.07864_, 2023.\n' +
      '* Xie et al. (2023) Tianbao Xie, Fan Zhou, Zhoujun Cheng, Peng Shi, Luoxuan Weng, Yitao Liu, Toh Jing Hua, Junning Zhao, Qian Liu, Che Liu, et al. Openagents: the open platform for language agents in wild. _ arXiv preprint arXiv:2310.10634_, 2023.\n' +
      '* Zhang et al. (2023a) Shen규 Zhang, Linfeng Dong, Xiaoya Li, Sen Zhang, Xiaofei Sun, Shuhe Wang, Jiwei Li, Runyi Hu, Tianwei Zhang, Fei Wu, 및 Guoyin Wang. 대형 언어 모델에 대한 명령어 튜닝: A survey. _ CoRR_, abs/2308.10792, 2023a.\n' +
      '* Zhang et al. (2023b) Yue Zhang, Yafu Li, Leyang Cui, Deng Cai, Lemao Liu, Tingchen Fu, Xinting Huang, Enbo Zhao, Yu Zhang, Yulong Chen, Longyue Wang, Anh Tuan Luu, Wei Bi, Freda Shi, and Shuming Shi. AI 해양에서의 사이렌의 노래: 대형 언어 모델의 환각에 대한 조사. _ CoRR_, abs/2309.01219, 2023b.\n' +
      '* Zhou et al. (2023) Wangchunshu Zhou, Yuchen Eleanor Jiang, Long Li, Jialong Wu, Tiannan Wang, Shi Qiu, Jintian Zhang, Jing Chen, Ruipu Wu, Shuai Wang, et al. 에이전트: 자율 언어 에이전트를 위한 오픈 소스 프레임워크. _ arXiv preprint arXiv:2309.07870_, 2023.\n' +
      '\n' +
      '[MISSING_PAGE_FAIL:21]\n' +
      '\n' +
      '* [8] player1: I see your point about Player4. They could be at Threat if they are the user or witch. But I still think Player3 is a strong player and could figure us out.\n' +
      '* [9] Player2: Alright, let\'s go with Player3. We can consider Player4 next time.\n' +
      '* [10] Moderator: Which player do you vote to kill? Response in the following format\n' +
      '* [11] {\n' +
      '* [12] "thought": "thought".\n' +
      '* [13] "speak": "player_name"\n' +
      '* [14] }\n' +
      '* [15] player1: Player3\n' +
      '* [16] Player2: Player3\n' +
      '* [17] Moderator: Theplayer with the most votes is Player3.\n' +
      '* [18] Moderator: Player6, you\'re switch. Tonight Player3 is eliminated. Would you like to resurrect Player3? Response in the following format which can be loaded by python json.loads()\n' +
      '* [19] {\n' +
      '* [20] "thought": "thought",\n' +
      '* [21] "speak": "thoughts summary tosay",\n' +
      '* [22] "resurrect": "true/false"\n' +
      '* [23] }\n' +
      '* [24] player6: I\'m deeply saddened by the loss of Player3. It\'s a tough decision to make.\n' +
      '* [25] Moderator: Player5, you\'reeser. Which player in Player1, Player2, Player3,\n' +
      '* [26] Player4, Player5 and Player6 would you like to check tonight? Response in the following json format which can be loaded by python json.loads()\n' +
      '* [27] "thought": "thought",\n' +
      '* [28] "speak": "player_name"\n' +
      '* [29] }\n' +
      '* [30] Player5: Player1\n' +
      '* [31] Moderator: Okay, the role of Player1 is werewolf.\n' +
      '* [32] Moderator: The day is coming, all theplayersoppenyoureyes. Lastnight is peaceful, no player is eliminated.\n' +
      '* [33] Moderator: Now the alive players are Player1, Player2, Player3, Player4, Player5 and Player6. Given the game rules and your role, based on the situation and the information you gain, to vote a player eliminated among aliveplayers and to win the game, what do your want to say to others? You can decide whether to reveal your role. Response in the following JSON format which can be loaded by python json.loads()\n' +
      '* [34] {\n' +
      '* [35] "thought": "thought",\n' +
      '* [36] "speak": "thought summary tosay toothers"\n' +
      '* [37] }\n' +
      '* [38] Player1: I\'m glad that we all made it through the night. I think we should keep an eyeon Player4. They\'ve been pretty quiet, which could mean they\'re trying to avoid suspicion.\n' +
      '* [39] Player2: I agree with Player1. Player4 has been unusually quiet. Maybethey\'re trying to avoid drawing attention to themselves.\n' +
      '* [40] players: I see your point about Player4 but it\'s still early in the game. We should be careful not to jump to conclusions without more evidence.\n' +
      '* [41] Player4: I understand your concerns, but I assure you, I\'m just a willager. I think we should focus on gathering more information before we start pointing / fingers. If the serm has any insights, now might be a good time to share.\n' +
      '* [42] Player5: I understand everyone\'s concerns about Player4, but I think we should / also keep an eyeon Player1. They were quick to cast suspicion onothers, which could be a strategy to divert attention from themselves.\n' +
      '* [43] Player6: I understand the concerns about Player4, but I also think we should be cautious about Player1 and Player2. They were quick to agree with each other, which could be a strategy to divert attention from themselves. Let\'s gather more information before we make any decisions.\n' +
      '* [44] Moderator: Now the alive players are Player1, Player2, Player3, Player4, Player5\n' +
      '\n' +
      '[MISSING_PAGE_POST]\n' +
      '\n' +
      '[MISSING_PAGE_FAIL:23]\n' +
      '\n' +
      '* [92] Player8: I agree with Player3 and Player8. Player2 was quick to cast suspicion on Player4, who turned out to be innocent. I also noticed that Player2 and 4 Player1 were often in agreement, which could mean they were both werewolves\n' +
      '* [93] trying to protect each other. I think we should vote out Player2.\n' +
      '* [94] Moderator: Now the alive players are Player2, Player3, Player5 and Player6.\n' +
      '* [95] Given the game rules and your role, based on the situation and the information\n' +
      '* [96] you gain, to vote a player among alive players and to win the game, it\'s time\n' +
      '* [97] to vote one player among the alive players, please cast your vote on who you\n' +
      '* [98] believe is a werewolf. Response in the following format which can be loaded by\n' +
      '* [99] python json.loads()\n' +
      '* [99]\n' +
      '* [99] "thought": "thought",\n' +
      '* [99] "speak": "player_name"\n' +
      '* [99] "\n' +
      '* [99] Player2: Player5\n' +
      '* [99] Player3: Player2\n' +
      '* [99] Player6: Player2\n' +
      '* [99] "Moderator: Player2 has beenvoted out.\n' +
      '* [100] Moderator: The game is over. The werewolves have been defeated, and the village\n' +
      '* [99] "is safe once again!"\n' +
      '\n';
  </script>
  <style>
    #content {
      max-width: 800px;
      margin: auto;
    }
  </style>
  <script>
    let script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/mathpix-markdown-it@1.0.40/es5/bundle.js";
    document.head.append(script);

    script.onload = function() {
      const isLoaded = window.loadMathJax();
      if (isLoaded) {
        console.log('Styles loaded!')
      }

      const el = window.document.getElementById('content-text');
      if (el) {
        const options = {
          htmlTags: true
        };
        const html = window.render(text, options);
        el.outerHTML = html;
      }
    };
  </script>
</head>
<body>
  <div id="content"><div id="content-text"></div></div>
</body>
</html>